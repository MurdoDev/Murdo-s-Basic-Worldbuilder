<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" 
      href="data:image/svg+xml,
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
        <rect width='100' height='100' fill='%23f3e8c8'/>
        <text x='50' y='70' font-size='50' font-family='Times' text-anchor='middle' fill='%238b5a30'>MW</text>
      </svg>">


  <meta charset="UTF-8">
  <title>Murdo's Worldbuilder</title>
  <style>
/* ===== Scrollbar styling for all themes ===== */
#toolbar::-webkit-scrollbar {
  width: 6px;
}

#toolbar::-webkit-scrollbar-track {
  background: transparent;
}

#toolbar::-webkit-scrollbar-thumb {
  border-radius: 10px;
  background: var(--scroll-thumb);
}

/* Light mode */
body:not(.dark):not(.fantasy-light):not(.fantasy-dark) {
  --scroll-thumb: rgba(0, 0, 0, 0.18);
}

/* Dark mode */
body.dark {
  --scroll-thumb: rgba(255, 255, 255, 0.18);
}

/* Fantasy Light */
body.fantasy-light {
  --scroll-thumb: rgba(120, 69, 30, 0.28);
}

/* Fantasy Dark */
body.fantasy-dark {
  --scroll-thumb: rgba(245, 230, 196, 0.25);
}

.search-block {
  margin-top: 10px;
  padding-top: 8px;
  border-top: 1px solid rgba(15,23,42,0.08);
}

.search-results {
  font-size: 12px;
  max-height: 120px;
  overflow-y: auto;
}

.search-result {
  padding: 4px 6px;
  border-radius: 4px;
  cursor: pointer;
}

.search-result:hover {
  background: rgba(37,99,235,0.08);
}

/* Dark + fantasy tweaks */
body.dark .search-block {
  border-top-color: #111827;
}
body.dark .search-result:hover {
  background: rgba(59,130,246,0.3);
}

body.fantasy-light .search-block {
  border-top-color: rgba(120,69,30,0.4);
}
body.fantasy-dark .search-block {
  border-top-color: #4b2c16;
}
body.fantasy-dark .search-result:hover {
  background: rgba(245,230,196,0.12);
}

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f6f8fb;
      overflow: hidden;
    }

    /* === LEFT TOOLBAR AS A FULL BAR === */
    #toolbar {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  width: 155px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
  border-right: 1px solid rgba(15,23,42,0.06);
  box-shadow: 3px 0 10px rgba(15,23,42,0.08);
  z-index: 10;

  /* ðŸ”½ added: allow internal scrolling when content overflows */
  overflow-y: auto;
  max-height: 100vh;

  scrollbar-width: thin;        /* Firefox */
  scrollbar-color: var(--scroll-thumb) transparent;
}

    .toolbar-section {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      align-items: flex-start;
      padding-bottom: 10px;
      border-bottom: 1px solid #e5e7eb;
    }

    .toolbar-section .section-title,
    .toolbar-section select,
    .toolbar-section .small-btn {
      grid-column: 1 / -1;
    }

    .toolbar-section .mode-button {
      justify-self: start;
    }

    .toolbar-section:last-child { border-bottom: none; }

    .section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--section-title-color);
    }

    /* === BUTTONS AS CARDS === */
    .mode-button {
      width: 64px;
      height: 64px;
      border: 1px solid rgba(15,23,42,0.06);
      background: #ffffff;
      border-radius: 14px;
      padding: 6px;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      cursor: pointer;
      text-align: center;
      color: #7a88a6;
      box-shadow: 0 6px 20px rgba(15,23,42,0.08);
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.15s ease, color 0.15s ease;
      white-space: normal;
    }
    .mode-button span.icon { font-size: 18px; margin-bottom: 2px; }
    .mode-button.active {
      outline: 2px solid rgba(59,130,246,0.18);
      box-shadow: 0 10px 30px rgba(59,130,246,0.15);
      background: #eff6ff;
      color: #0f172a;
    }
    .mode-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(15,23,42,0.12);
      background: #f9fafb;
    }
    .mode-button.active:hover {
      background: #e0ecff;
    }

    select {
      border-radius: 999px;
      border: 1px solid #d1d5db;
      padding: 4px 8px;
      font-size: 12px;
      background: #f9fafb;
      cursor: pointer;
    }

    button.small-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      border-radius: 14px;
      border: 1px solid rgba(16,185,129,0.6);
      padding: 8px 12px;
      font-size: 12px;
      background: #10b981;
      color: white;
      box-shadow: 0 6px 18px rgba(16,185,129,0.45);
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.15s ease;
      white-space: nowrap;
    }
    button.small-btn:hover {
      background: #059669;
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(16,185,129,0.55);
    }

    /* === SIDEBAR (RIGHT) PANEL STYLE === */
    #sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: 260px;
      height: 100vh;
      background: linear-gradient(180deg,#ffffff 0%, #fbfdff 100%);
      border-left: 1px solid rgba(15,23,42,0.04);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 5;
      box-shadow: -6px 0 20px rgba(15,23,42,0.06);
    }

    #sidebar > * {
      background: #ffffff;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 20px rgba(15,23,42,0.08);
    }

    #sidebar h2 {
      margin: 0 0 4px;
      font-size: 16px;
      font-weight: 600;
      color: #111827;
    }

    #sidebar h3 {
      margin: 10px 0 4px;
      font-size: 13px;
      font-weight: 600;
      color: #374151;
    }

    #sidebar p {
      margin: 0;
      font-size: 12px;
      color: #6b7280;
    }

    .field-group {
      display: flex;
      flex-direction: column;
      margin-bottom: 6px;
    }
    .field-group label {
      font-size: 11px;
      color: #4b5563;
      margin-bottom: 2px;
    }
    .field-group input,
    .field-group select,
    .field-group textarea {
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(15,23,42,0.08);
      background: #f9fafb;
      outline: none;
      box-shadow: 0 1px 2px rgba(15,23,42,0.03) inset;
    }
    .field-group input:focus,
    .field-group select:focus,
    .field-group textarea:focus {
      border-color: #2563eb;
      background: #ffffff;
      box-shadow: 0 0 0 1px rgba(37,99,235,0.15);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 999px;
      background: #eff6ff;
      color: #1d4ed8;
      margin-bottom: 4px;
      font-weight: 500;
    }

    textarea {
      resize: vertical;
      min-height: 50px;
      max-height: 120px;
    }

    /* Canvas between toolbar and sidebar */
    #canvas {
      position: fixed;
      top: 0;
      left: 230px;
      background: #ffffff;
      z-index: 0;
    }

    .connection-legend {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 2px;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: #4b5563;
    }
    .legend-color {
      width: 14px;
      height: 8px;
      border-radius: 3px;
    }

    /* Explosion GIF overlay */
    .explosion-gif {
      position: fixed;
      width: 128px;
      height: 128px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 999;
    }

    /* =================== DARK MODE OVERRIDES =================== */
    body.dark {
      background: #020617;
      color: #e5e7eb;
    }

    body.dark #toolbar {
      background: linear-gradient(180deg,#020617 0%, #020617 100%);
      border-right: 1px solid #111827;
      box-shadow: 3px 0 16px rgba(0,0,0,0.7);
    }
    body.dark .toolbar-section {
      border-bottom: 1px solid #111827;
    }
    body.dark .section-title {
      color: #9ca3af;
    }

    body.dark .mode-button {
      background: #020617;
      border-color: #111827;
      color: #9ca3af;
      box-shadow: 0 6px 20px rgba(0,0,0,0.8);
    }
    body.dark .mode-button.active {
      background: #111827;
      color: #e5e7eb;
      outline-color: rgba(59,130,246,0.5);
      box-shadow: 0 10px 30px rgba(15,23,42,0.9);
    }
    body.dark .mode-button:hover {
      background: #020617;
      box-shadow: 0 10px 30px rgba(0,0,0,0.9);
    }

    body.dark button.small-btn {
      background: #16a34a;
      border-color: rgba(34,197,94,0.9);
      box-shadow: 0 8px 22px rgba(22,163,74,0.9);
      color: #e5e7eb;
    }
    body.dark button.small-btn:hover {
      background: #22c55e;
    }

    body.dark #sidebar {
      background: linear-gradient(180deg,#020617 0%, #020617 100%);
      border-left: 1px solid #111827;
      box-shadow: -6px 0 24px rgba(0,0,0,0.85);
    }
    body.dark #sidebar > * {
      background: #020617;
      border: 1px solid #111827;
      box-shadow: 0 6px 20px rgba(0,0,0,0.9);
    }
    body.dark #sidebar h2,
    body.dark #sidebar h3 {
      color: #e5e7eb;
    }
    body.dark #sidebar p,
    body.dark .legend-item {
      color: #9ca3af;
    }

    body.dark .field-group input,
    body.dark .field-group select,
    body.dark .field-group textarea {
      background: #020617;
      border-color: #1f2937;
      color: #e5e7eb;
      box-shadow: 0 0 0 1px rgba(15,23,42,0.7) inset;
    }
    body.dark .field-group input:focus,
    body.dark .field-group select:focus,
    body.dark .field-group textarea:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px rgba(59,130,246,0.7);
      background: #020617;
    }

    body.dark #canvas {
      background: #020617;
    }

    /* =================== FANTASY THEMES =================== */
    body.fantasy-light #sidebar,
    body.fantasy-dark #sidebar,
    body.fantasy-light #toolbar,
    body.fantasy-dark #toolbar {
      font-family: Georgia, "Times New Roman", serif;
    }

    body.fantasy-light {
      background: #f3e8c8;
      color: #3b2f2f;
    }

    body.fantasy-dark {
      background: #553e30;
      color: #f5e6c4;
    }

    body.fantasy-light,
    body.fantasy-dark {
      font-family: Georgia, "Times New Roman", serif;
    }

    body.fantasy-light #toolbar {
      background: linear-gradient(180deg, #f3e8c8 0%, #f1e0b5 100%);
      border-right: 1px solid rgba(120, 69, 30, 0.5);
      box-shadow: 3px 0 16px rgba(120, 69, 30, 0.5);
    }

    body.fantasy-light #sidebar {
      background: linear-gradient(180deg, #f3e8c8 0%, #f1e0b5 100%);
      border-left: 1px solid rgba(120, 69, 30, 0.4);
      box-shadow: -6px 0 18px rgba(120, 69, 30, 0.4);
    }

    body.fantasy-light #sidebar > * ,
    body.fantasy-light .mode-button {
      background: #f6ecd1;
      border-color: rgba(120, 69, 30, 0.4);
      box-shadow: 0 6px 18px rgba(120, 69, 30, 0.35);
      color: #3b2f2f;
    }

    body.fantasy-light #sidebar p,
    body.fantasy-light .legend-item {
      color: #3b2f2f;
    }

    body.fantasy-light #sidebar h2,
    body.fantasy-light #sidebar h3 {
      color: #3b2f2f;
    }

    body.fantasy-light #canvas {
      background: #f3e8c8;
    }

    body.fantasy-light .field-group input,
    body.fantasy-light .field-group select,
    body.fantasy-light .field-group textarea {
      background: #f6ecd1;
      border-color: rgba(120, 69, 30, 0.4);
      color: #3b2f2f;
    }

    body.fantasy-dark #toolbar {
      background: linear-gradient(180deg, #1b130e 0%, #140d09 100%);
      border-right: 1px solid #3b2413;
      box-shadow: 3px 0 20px rgba(0, 0, 0, 0.8);
    }

    body.fantasy-dark #sidebar {
      background: linear-gradient(180deg, #1b130e 0%, #140d09 100%);
      border-left: 1px solid #3b2413;
      box-shadow: -6px 0 22px rgba(0, 0, 0, 0.85);
    }

    body.fantasy-dark #sidebar > * ,
    body.fantasy-dark .mode-button {
      background: #24160f;
      border: 1px solid #4b2c16;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.9);
      color: #f5e6c4;
    }

    body.fantasy-light .mode-button.active {
      background: #f6f0d8;
      outline: 2px solid rgba(176,140,61,0.7);
      box-shadow: 0 10px 26px rgba(176,140,61,0.5);
      color: #3b2f2f;
    }

    body.fantasy-dark .mode-button.active {
      background: #3a2516;
      outline: 2px solid rgba(215,190,130,0.8);
      box-shadow: 0 10px 26px rgba(0,0,0,0.9);
      color: #f5e6c4;
    }

    body.fantasy-dark #sidebar h2,
    body.fantasy-dark #sidebar h3 {
      color: #f5e6c4;
    }

    body.fantasy-dark #sidebar p,
    body.fantasy-dark .legend-item {
      color: #e5d5b4;
    }

    body.fantasy-dark .field-group input,
    body.fantasy-dark .field-group select,
    body.fantasy-dark .field-group textarea {
      background: #1b130e;
      border-color: #4b2c16;
      color: #f5e6c4;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.7) inset;
    }

    body.fantasy-dark #canvas {
      background: #1b130e;
    }

    /* ======= NEW: Section title colors via CSS variable ======= */
    body {
      --section-title-color: #6b7280;
    }
    body.dark {
      --section-title-color: #9ca3af;
    }
    body.fantasy-light {
      --section-title-color: #5a4633;
    }
    body.fantasy-dark {
      --section-title-color: #f5e6c4;
    }

    /* ======= NEW: Force fantasy font on ALL toolbar text ======= */
    body.fantasy-light #toolbar *,
    body.fantasy-dark  #toolbar * {
      font-family: Georgia, "Times New Roman", serif !important;
    }

    /* ======= NEW: Regal gold selects in fantasy modes ======= */
    body.fantasy-light select,
    body.fantasy-dark  select {
      background: linear-gradient(180deg, #f8e7b0, #e8c978);
      border: 1px solid #b08c3d;
      color: #3b2f2f;
      box-shadow: 0 2px 8px rgba(176, 140, 61, 0.5);
    }

    body.fantasy-light select option {
      color: #3b2f2f !important;
      background: #ffffff !important;
    }

    body.fantasy-dark select option {
      color: #f5e6c4 !important;
      background: #2b1a12 !important;
    }

    body.fantasy-dark select {
      background: linear-gradient(180deg, #8a6a2f, #6d5225);
      color: #f5e6c4;
      border-color: #d7be82;
      box-shadow: 0 2px 12px rgba(215, 190, 130, 0.5);
    }

    body.fantasy-light button.small-btn,
    body.fantasy-dark  button.small-btn {
      background: linear-gradient(180deg, #1cb924, #1d7f2a);
      border: 1px solid #11693d;
      color: #f2fef2;
      box-shadow: 0 3px 10px rgba(32, 127, 29, 0.7);
    }

    body.fantasy-light button.small-btn:hover,
    body.fantasy-dark  button.small-btn:hover {
      background: linear-gradient(180deg, #26dc2f, #1b9925);
      transform: translateY(-2px);
      box-shadow: 0 4px 14px rgba(41, 185, 28, 0.8);
    }
#copyright {
  position: fixed;
  right: 10px;
  bottom: 10px;
  font-size: 11px;
  font-family: Georgia, "Times New Roman", serif;
  pointer-events: none;
  z-index: 9999;
  text-align: right;
}

/* Light mode â€“ white background */
body:not(.dark):not(.fantasy-light):not(.fantasy-dark) #copyright {
  color: rgba(0, 0, 0, 0.12);   /* very soft grey */
}

/* Dark mode â€“ navy/black background */
body.dark #copyright {
  color: rgba(255, 255, 255, 0.10); /* faint white */
}

/* Fantasy Light â€“ parchment background (#f3e8c8) */
body.fantasy-light #copyright {
  color: rgba(59, 47, 47, 0.22);  /* soft brown, barely visible */
}

/* Fantasy Dark â€“ deep brown background (#1b130e) */
body.fantasy-dark #copyright {
  color: rgba(245, 230, 196, 0.15); /* parchment-gold but very faint */
}
/* Make sidebar labels follow the theme */
body.dark .field-group label {
  color: #e5e7eb;
}

body.fantasy-light .field-group label {
  color: #5a4633;
}

body.fantasy-dark .field-group label {
  color: #f5e6c4;
}

/* Search placeholder colours per theme */
.search-block input::placeholder {
  color: rgba(107,114,128,0.9); /* default light */
}

body.dark .search-block input::placeholder {
  color: rgba(209,213,219,0.7);
}

body.fantasy-light .search-block input::placeholder {
  color: rgba(90,70,51,0.7);
}

body.fantasy-dark .search-block input::placeholder {
  color: rgba(245,230,196,0.7);
}

  </style>
</head>
<body>

  <!-- LEFT BAR TOOLBAR -->
  <div id="toolbar">
    <div class="toolbar-section">
  <span class="section-title">Tools</span>
  <button class="mode-button active" data-mode="move">
    <span class="icon">â†•</span><span>Move</span>
  </button>
  <button class="mode-button" data-mode="connect">
    <span class="icon">âš­</span><span>Connect</span>
  </button>
  <button class="mode-button" data-mode="edit">
    <span class="icon">âœŽ</span><span>Edit</span>
  </button>
  <button class="mode-button" data-mode="delete">
    <span class="icon">âœ—</span><span>Delete</span>
  </button>
  <button class="mode-button" data-mode="explode">
    <span class="icon">â—Ž</span><span>Explode</span>
  </button>
  <button class="mode-button" data-mode="duplicate">
    <span class="icon">â§‰</span><span>Duplicate</span>
  </button>
  <button class="mode-button" data-mode="autoconnect">
    <span class="icon">ðŸ—²</span><span>Auto Connect</span>
  </button>
    <button class="mode-button" data-mode="isolate">
    <span class="icon">âŠ˜</span><span>Isolate</span>
  </button>
</div>


    <div class="toolbar-section">
      <span class="section-title">Node Manager</span>
      <select id="nodeTypeSelect">
        <option value="character">Character</option>
        <option value="location">Location</option>
        <option value="item">Item</option>
        <option value="note">Note</option>
        <option value="book">Book</option>
    </select>
      <button id="newNodeButton" class="small-btn">
        <span>âž•</span><span>Create Node</span>
      </button>
      <button id="newBubbleButton" class="small-btn">
        <span>âšª</span><span>Create Bubble</span>
      </button>
    </div>

    <div class="toolbar-section">
      <span class="section-title">Connection Type</span>
      <select id="connectionTypeSelect">
        <option value="friends">Friends</option>
        <option value="family">Family</option>
        <option value="romantic">Romantic</option>
        <option value="enemy">Enemy</option>
        <option value="neutral">Neutral</option>
        <option value="traitor">Traitor</option>
        <option value="ex">Ex-relationship</option>
        <option value="parent">Parent/Caretaker</option>
        <option value="coworker">Coworkers</option>
      </select>
    </div>



    <div class="toolbar-section">
      <span class="section-title">Save to Browser</span>
      <button id="saveButton" class="mode-button">
        <span class="icon">â¤“</span><span>Save</span>
      </button>
      <button id="loadButton" class="mode-button">
        <span class="icon">â¤’</span><span>Load</span>
      </button>
      <button id="clearButton" class="mode-button">
        <span class="icon">â†º</span><span>Clear</span>
      </button>
    </div>

    <div class="toolbar-section">
      <span class="section-title">Save to Device</span>
      <button id="saveJsonButton" class="mode-button">
        <span class="icon">â¤“</span><span>Save JSON</span>
      </button>
      <button id="loadJsonButton" class="mode-button">
        <span class="icon">â¤’</span><span>Load JSON</span>
      </button>
    </div>

    <div class="toolbar-section">
      <span class="section-title">Theme</span>
      <button id="themeToggle" class="mode-button">
        <span class="icon">â˜½</span><span>Dark</span>
      </button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <!-- Explosion sound -->
  <audio
    id="explosionSound"
    src="https://www.myinstants.com/media/sounds/deltarune-explosion.mp3"
  ></audio>

  <input type="file" id="jsonFileInput" accept="application/json" style="display:none" />

  <!-- RIGHT SIDEBAR -->
  <div id="sidebar">
    <div>
      <h2>No node selected</h2>
      <p>Switch to <strong>Edit</strong> mode and click a node to see its details here.</p>
      <h3>Connection Types</h3>
      <div class="connection-legend">
        <div class="legend-item"><span class="legend-color" style="background:#2196f3;"></span>friends</div>
        <div class="legend-item"><span class="legend-color" style="background:#ffd335;"></span>family</div>
        <div class="legend-item"><span class="legend-color" style="background:#e68de0;"></span>romantic</div>
        <div class="legend-item"><span class="legend-color" style="background:#f44336;"></span>enemy</div>
        <div class="legend-item"><span class="legend-color" style="background:#bdbdbd;"></span>neutral</div>
        <div class="legend-item"><span class="legend-color" style="background:#000000;"></span>traitor</div>
        <div class="legend-item"><span class="legend-color" style="background:#8b5cf6;"></span>ex-relationship</div>
        <div class="legend-item"><span class="legend-color" style="background:#ffeb3b;"></span>parent/caretaker</div>
        <div class="legend-item"><span class="legend-color" style="background:#4caf50;"></span>coworkers</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sidebar = document.getElementById("sidebar");
    const toolbarEl = document.getElementById("toolbar");

    // ---- Theme state ----
    const THEMES = ["light", "dark", "fantasyLight", "fantasyDark"];
    let currentThemeIndex = 0;
    let darkMode = false;

    const storedThemeIndex = parseInt(localStorage.getItem("nb_themeIndex"), 10);
    if (!Number.isNaN(storedThemeIndex) &&
        storedThemeIndex >= 0 &&
        storedThemeIndex < THEMES.length) {
      currentThemeIndex = storedThemeIndex;
    }

    function getCurrentTheme() {
      return THEMES[currentThemeIndex];
    }

    // ---- Pan & zoom ----
    let panX = 0;
    let panY = 0;
    let scale = 1;
    const MIN_SCALE = 0.2;
    const MAX_SCALE = 2;

    const storedView = localStorage.getItem("nb_view");
    if (storedView) {
      try {
        const v = JSON.parse(storedView);
        if (typeof v.panX === "number") panX = v.panX;
        if (typeof v.panY === "number") panY = v.panY;
        if (typeof v.scale === "number") scale = v.scale;
      } catch (e) {
        console.error("Failed to restore view", e);
      }
    }

    function resizeCanvas() {
      const sidebarWidth = sidebar.offsetWidth || 260;
      const toolbarWidth = toolbarEl.offsetWidth || 230;
      canvas.style.left = toolbarWidth + "px";
      canvas.width = window.innerWidth - sidebarWidth - toolbarWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function screenToWorld(x, y) {
      return {
        x: (x - panX) / scale,
        y: (y - panY) / scale,
      };
    }

    // ---- State ----
    let nodes = [];
    let edges = [];
    let bubbles = [];
    let nextNodeId = 1;
    let nextBubbleId = 1;

    const MODES = {
  MOVE: "move",
  CONNECT: "connect",
  EDIT: "edit",
  DELETE: "delete",
  EXPLODE: "explode",
  DUPLICATE: "duplicate",
  AUTOCONNECT: "autoconnect",
  ISOLATE: "isolate",
};


    let currentMode = MODES.MOVE;

    const edgeColors = {
      friends: "#2196f3",
      family: "#ffd335",
      romantic: "#e68de0",
      enemy: "#f44336",
      neutral: "#bdbdbd",
      traitor: "#000000",
      ex: "#8b5cf6",
      parent: "#ffeb3b",
      coworker: "#4caf50",
    };

    // Node-node repulsion radius (existing)
    const BUBBLE_RADIUS = 190;
    const BUBBLE_FORCE = 40;

    // Bubble shell behaviour
    const BUBBLE_BASE_RADIUS = 160;
    const BUBBLE_GROWTH_PER_NODE = 17.5;
    const BUBBLE_INNER_STRENGTH = 400;
    const BUBBLE_OUTER_STRENGTH = 40;
    const BUBBLE_WALL_THICKNESS = 160;   // how wide the force ring is
    const BUBBLE_WALL_FORCE = 50;     // strength of the wall push

    // Autoconnect detection radius
    const AUTO_CONNECT_RADIUS = 400; // world units

    const SPRING_LENGTH = 250;
    const SPRING_STRENGTH = 0.06;
    const DAMPING = 0.7;

    let draggingNode = null;
    let draggingBubble = null;
    let dragTarget = { x: 0, y: 0 };
    let bubbleDragTarget = { x: 0, y: 0 };
    let isPanning = false;
    let lastPanScreen = { x: 0, y: 0 };

    let selectedNode = null;
    let selectedBubble = null;
    let connectSourceNode = null;

  const NODE_WIDTH = 140;
const NODE_HEIGHT = 80;
const NODE_RADIUS = 20;
const NODE_MAX_WIDTH = NODE_WIDTH * 3; // notes can grow up to this Ã— width

const NOTE_MAX_TITLE_CHARS   = 18;
const NOTE_MAX_CONTENT_CHARS = 2700;

const BOOK_TITLE_MAX_CHARS = 20;
const BOOK_PAGE_MAX_CHARS  = 100;

// === BOOK CONSTANTS ===
const BOOK_CLOSED_HEIGHT = 200;
const BOOK_CLOSED_WIDTH  = (BOOK_CLOSED_HEIGHT * 4) / 5; // closed (portrait)
const BOOK_OPEN_HEIGHT   = BOOK_CLOSED_HEIGHT;
const BOOK_OPEN_WIDTH    = BOOK_CLOSED_WIDTH * 2 + 20;   // 6x4 spread + small spine gap

const BOOK_COVER_COLORS = [
  "#1C1E4F", // deep indigo
  "#601919", // dark red
  "#36225A", // purple
  "#203F31"  // deep green
];

const BOOK_MAX_PAGES = 30;



// when note is at max width, cap body lines:
const NOTE_MAX_BODY_LINES_AT_MAX_WIDTH = 16; // tweak to taste


    // ---- Autosave restore ----
    (function restoreAutosave() {
      const savedNodes = localStorage.getItem("nb_nodes_auto");
      const savedEdges = localStorage.getItem("nb_edges_auto");
      const savedBubbles = localStorage.getItem("nb_bubbles_auto");
      if (!savedNodes || !savedEdges) return;

      try {
        nodes = JSON.parse(savedNodes);
        edges = JSON.parse(savedEdges);
        bubbles = savedBubbles ? JSON.parse(savedBubbles) : [];

        edges.forEach(e => {
          if (!e.direction) e.direction = "forward";
        });
        normalizeEdges();

        nodes.forEach(n => {
          if (typeof n.vx !== "number") n.vx = 0;
          if (typeof n.vy !== "number") n.vy = 0;
        });
        bubbles.forEach(b => {
          if (typeof b.vx !== "number") b.vx = 0;
          if (typeof b.vy !== "number") b.vy = 0;
          if (typeof b.radius !== "number") b.radius = BUBBLE_BASE_RADIUS;
        });

        nextNodeId = nodes.reduce((max, n) => Math.max(max, n.id), 0) + 1;
        nextBubbleId = bubbles.reduce((max, b) => Math.max(max, b.id), 0) + 1;
      } catch (e) {
        console.error("Failed to restore autosave", e);
        nodes = [];
        edges = [];
        bubbles = [];
        nextNodeId = 1;
        nextBubbleId = 1;
      }
    })();

    function getNodeAtWorld(x, y) {
  for (let n of nodes) {
    // Make sure notes have an up-to-date layout before we use width/height
    if (n.type === "note") {
      measureNoteLayout(n);
    } else {
      // give non-notes a default layout so layoutWidth/layoutHeight are defined
      n.layoutWidth  = NODE_WIDTH;
      n.layoutHeight = NODE_HEIGHT;
    }

    const w = n.layoutWidth || NODE_WIDTH;
    const h = n.layoutHeight || NODE_HEIGHT;

    if (
      x >= n.x - w / 2 &&
      x <= n.x + w / 2 &&
      y >= n.y - h / 2 &&
      y <= n.y + h / 2
    ) {
      return n;
    }
  }
  return null;
}



    function getBubbleAtWorld(x, y) {
      for (let b of bubbles) {
        const dx = x - b.x;
        const dy = y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= (b.radius || BUBBLE_BASE_RADIUS)) return b;
      }
      return null;
    }

    function getNodeById(id) {
      return nodes.find(n => n.id === id) || null;
    }

    function buildEdgeGroups() {
  // Group by unordered pair, then split into forward/backward/both
  const groups = {};

  edges.forEach((e, index) => {
    const a = e.fromId;
    const b = e.toId;
    const minId = Math.min(a, b);
    const maxId = Math.max(a, b);
    const key = minId + "-" + maxId;

    if (!groups[key]) {
      groups[key] = { forward: [], backward: [], both: [] };
    }

    const dir = e.direction || "forward";

    if (dir === "both") {
      groups[key].both.push(index);
    } else {
      // "forward" means minId -> maxId, "backward" means maxId -> minId
      if (e.fromId === minId) {
        groups[key].forward.push(index);
      } else {
        groups[key].backward.push(index);
      }
    }
  });

  // Stable sort inside each lane so positions don't jump around
  for (const key in groups) {
    const g = groups[key];
    ["both", "forward", "backward"].forEach(kind => {
      g[kind].sort((i1, i2) => {
        const e1 = edges[i1];
        const e2 = edges[i2];
        const k1 = `${e1.type}|${e1.direction || "forward"}|${e1.fromId}-${e1.toId}`;
        const k2 = `${e2.type}|${e2.direction || "forward"}|${e2.fromId}-${e2.toId}`;
        return k1.localeCompare(k2);
      });
    });
  }

  return groups;
}


    function normalizeEdges() {
      const byKey = {};
      for (const e of edges) {
        const baseKey =
          e.type + ":" + (e.fromId < e.toId ? e.fromId + "-" + e.toId : e.toId + "-" + e.fromId);

        const dir = e.direction || "forward";
        if (!byKey[baseKey]) {
          byKey[baseKey] = {
            fromId: e.fromId,
            toId: e.toId,
            type: e.type,
            direction: dir,
          };
        } else {
          const ex = byKey[baseKey];
          if (ex.direction === "both" || dir === "both") {
            ex.direction = "both";
          } else if (ex.fromId !== e.fromId) {
            ex.direction = "both";
          }
        }
      }
      edges = Object.values(byKey);
    }

    function getEdgeAtWorld(x, y) {
  const thresholdWorld = 6 / scale;
  const groups = buildEdgeGroups();

  let closestIndex = -1;
  let closestDist = Infinity;

  const laneBase   = 6 / scale;
  const laneSpread = 4 / scale;

  for (const key in groups) {
    const bundle = groups[key];
    const [minIdStr, maxIdStr] = key.split("-");
    const minId = Number(minIdStr);
    const maxId = Number(maxIdStr);

    const nodeA = getNodeById(minId);
    const nodeB = getNodeById(maxId);
    if (!nodeA || !nodeB) continue;

    let baseAx = nodeA.x;
    let baseAy = nodeA.y;
    let baseBx = nodeB.x;
    let baseBy = nodeB.y;

    let dx = baseBx - baseAx;
    let dy = baseBy - baseAy;
    let dist = Math.hypot(dx, dy) || 1;
    dx /= dist;
    dy /= dist;

    const perpX = -dy;
    const perpY = dx;

    const laneDefs = [
      { kind: "both",     side: 0 },
      { kind: "forward",  side: 1 },
      { kind: "backward", side: -1 }
    ];

    for (const lane of laneDefs) {
      const arr = bundle[lane.kind];
      if (!arr || arr.length === 0) continue;

      const groupSize = arr.length;
      const centerIndex = (groupSize - 1) / 2;

      for (let gi = 0; gi < arr.length; gi++) {
        const edgeIndex = arr[gi];
        const e = edges[edgeIndex];
        const fromNode = getNodeById(e.fromId);
        const toNode = getNodeById(e.toId);
        if (!fromNode || !toNode) continue;

        const laneOffset = lane.side * laneBase;
        const internalOffset = (gi - centerIndex) * laneSpread;
        const offsetWorld = laneOffset + internalOffset;

        const offX = perpX * offsetWorld;
        const offY = perpY * offsetWorld;

        let ax = fromNode.x + offX;
        let ay = fromNode.y + offY;
        let bx = toNode.x + offX;
        let by = toNode.y + offY;

        const vx = bx - ax;
        const vy = by - ay;
        const lenSq = vx * vx + vy * vy;
        if (!lenSq) continue;

        const t = Math.max(
          0,
          Math.min(1, ((x - ax) * vx + (y - ay) * vy) / lenSq)
        );
        const projX = ax + t * vx;
        const projY = ay + t * vy;
        const d = Math.hypot(x - projX, y - projY);

        if (d < thresholdWorld && d < closestDist) {
          closestDist = d;
          closestIndex = edgeIndex;
        }
      }
    }
  }

  return closestIndex;
}


    function nodeDisplayLabel(node) {
  if (node.type === "character") return node.data.name || "Character";
  if (node.type === "location") return node.data.name || "Location";
  if (node.type === "item") return node.data.name || "Item";
  if (node.type === "note") return node.data.title || "Note";
  if (node.type === "book") return node.data.title || "Book";
  return "Node";
}



    function createNode(type, x, y) {
  let data = {};
  if (type === "character") {
    data = {
      name: "New Character",
      age: "",
      dob: "",
      species: "",
      height: "",
      weight: "",
      gender: "",
    };
  } else if (type === "location") {
    data = {
      name: "New Location",
      category: "town",
      customCategory: "",
    };
  } else if (type === "item") {
    data = {
      name: "New Item",
      itemType: "",
      special: "",
    };
    } else if (type === "note") {
    data = {
      title: "New Note",
      content: "",
    };
  } else if (type === "book") {
    data = {
      title: "New Book",
      coverColor: BOOK_COVER_COLORS[0],
      pages: Array.from({ length: BOOK_MAX_PAGES }, () => ""),
      currentPage: 0, // index 0â€“29
    };
  }


    const node = {
    id: nextNodeId++,
    type,
    data,
    x,
    y,
    vx: 0,
    vy: 0,
    // collapsed by default for notes
    isExpanded: type === "note" ? false : undefined,
    // closed by default for books
    isOpen: type === "book" ? false : undefined,
  };


  nodes.push(node);
  return node;
}


    function createBubble(x, y) {
      const bubble = {
        id: nextBubbleId++,
        name: "New Bubble",
        x,
        y,
        radius: BUBBLE_BASE_RADIUS,
        vx: 0,
        vy: 0,
        nodeCount: 0,
      };
      bubbles.push(bubble);
      return bubble;
    }
 
   function duplicateNode(node) {
      const clonedData = JSON.parse(JSON.stringify(node.data));

      const copy = {
        id: nextNodeId++,
        type: node.type,
        data: clonedData,
        x: node.x + 40, // offset so itâ€™s not directly on top
        y: node.y + 40,
        vx: 0,
        vy: 0,
      };

      nodes.push(copy);
      return copy;
    }

    function countNodesInBubble(bubble) {
      let count = 0;
      const R = bubble.radius || BUBBLE_BASE_RADIUS;
      for (const n of nodes) {
        const dx = n.x - bubble.x;
        const dy = n.y - bubble.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= R) count++;
      }
      return count;
    }

    function updateBubbleRadiiAndCounts() {
      bubbles.forEach(b => {
        const count = countNodesInBubble(b);
        b.nodeCount = count;
        const targetRadius = BUBBLE_BASE_RADIUS + count * BUBBLE_GROWTH_PER_NODE;
        if (typeof b.radius !== "number") b.radius = BUBBLE_BASE_RADIUS;
        b.radius += (targetRadius - b.radius) * 0.15; // smooth growth
      });
    }

    function drawGrid() {
      const gridSize = 70;
      const left = (0 - panX) / scale;
      const right = (canvas.width - panX) / scale;
      const top = (0 - panY) / scale;
      const bottom = (canvas.height - panY) / scale;

      const startX = Math.floor(left / gridSize) * gridSize;
      const endX = Math.ceil(right / gridSize) * gridSize;
      const startY = Math.floor(top / gridSize) * gridSize;
      const endY = Math.ceil(bottom / gridSize) * gridSize;

      const theme = getCurrentTheme();
      let dotColor;

      if (theme === "fantasyLight") {
        dotColor = "#d1b891";
      } else if (theme === "fantasyDark") {
        dotColor = "#3b2413";
      } else {
        dotColor = darkMode ? "#1f2937" : "#e5e7eb";
      }

      ctx.fillStyle = dotColor;
      const dotRadiusWorld = 1.5 / scale;
      for (let x = startX; x <= endX; x += gridSize) {
        for (let y = startY; y <= endY; y += gridSize) {
          ctx.beginPath();
          ctx.arc(x, y, dotRadiusWorld, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
function measureNoteLayout(n) {
  // Screen-space padding and line height (convert to world via scale)
  const paddingXpx = 16;
  const paddingYpx = 12;
  const lineHeightPx = 16;

  const paddingX = paddingXpx / scale;
  const paddingY = paddingYpx / scale;

  const minWidthWorld = NODE_WIDTH;
  // ORIGINAL:
// const maxWidthWorld = NODE_MAX_WIDTH;

// NEW: limit physical width when zoomed in
let maxWidthWorld = NODE_MAX_WIDTH;

// If zoomed in, convert a max pixel width to world units
const MAX_ZOOMED_IN_WIDTH_PX = 900;   // tweak as needed
if (scale > 1.25) {
  const maxZoomedWorld = MAX_ZOOMED_IN_WIDTH_PX / scale;
  maxWidthWorld = Math.min(maxWidthWorld, maxZoomedWorld);
}


  const theme = getCurrentTheme();
  let labelFontFamily =
    "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
  if (theme === "fantasyLight" || theme === "fantasyDark") {
    labelFontFamily = "Georgia, 'Times New Roman', serif";
  }

  const titleText   = (n.data.title   || "Note").trim();
  const contentText = (n.data.content || "").trim();
  const isExpanded  = !!n.isExpanded;

  // ðŸ”‘ use the same pixel sizes as in drawRoundedNode
  const TITLE_FONT_PX = 14;
  const BODY_FONT_PX  = 12;
  const HINT_FONT_PX  = 11;

  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0); // measure in raw pixels

  const minInnerPx = (minWidthWorld - 2 * paddingX) * scale;
  const maxInnerPx = (maxWidthWorld - 2 * paddingX) * scale;

  // generic wrapper with a specific font size
  function wrapInto(linesArr, text, maxPx, fontPx) {
    ctx.font = `${fontPx}px ${labelFontFamily}`;

    if (!text) {
      linesArr.push("");
      return 0;
    }

    const words = text.split(/\s+/);
    let current = "";
    let longest = 0;

    function flush() {
      if (current) {
        linesArr.push(current);
        const w = ctx.measureText(current).width;
        if (w > longest) longest = w;
        current = "";
      }
    }

    function breakLongWord(word) {
      let part = "";
      for (const ch of word) {
        const test = part + ch;
        const w = ctx.measureText(test).width;
        if (w <= maxPx || !part) {
          part = test;
        } else {
          linesArr.push(part);
          const pw = ctx.measureText(part).width;
          if (pw > longest) longest = pw;
          part = ch;
        }
      }
      if (part) {
        linesArr.push(part);
        const pw = ctx.measureText(part).width;
        if (pw > longest) longest = pw;
      }
    }

    for (const word of words) {
      const wordWidth = ctx.measureText(word).width;
      if (wordWidth > maxPx) {
        flush();
        breakLongWord(word);
        continue;
      }

      const test = current ? current + " " + word : word;
      const testWidth = ctx.measureText(test).width;

      if (testWidth <= maxPx || !current) {
        current = test;
      } else {
        flush();
        current = word;
      }
    }
    flush();
    return longest;
  }

  // ---------- COLLAPSED ----------

  if (!isExpanded) {
    const collapsedLines = [];

    // use a narrower limit so it never hits the curve
    const titleMaxPx = maxInnerPx * 0.55;

    const titleLinesTemp = [];
    wrapInto(titleLinesTemp, titleText || "Note", titleMaxPx, TITLE_FONT_PX);

    // collapsed: only one line, truncated with ellipsis
    ctx.font = `${TITLE_FONT_PX}px ${labelFontFamily}`;
    let firstLine = titleLinesTemp[0] || "Note";
    while (
      firstLine.length > 1 &&
      ctx.measureText(firstLine).width > titleMaxPx
    ) {
      firstLine = firstLine.slice(0, -1);
    }
    if (titleLinesTemp.length > 1 && !firstLine.endsWith("â€¦")) {
      firstLine += "â€¦";
    }

    collapsedLines.push(firstLine);

    const hintLine = "(click to expand)";
    ctx.font = `${HINT_FONT_PX}px ${labelFontFamily}`;
    collapsedLines.push(hintLine);

    ctx.font = `${TITLE_FONT_PX}px ${labelFontFamily}`;
    const w1 = ctx.measureText(firstLine).width;

    ctx.font = `${HINT_FONT_PX}px ${labelFontFamily}`;
    const w2 = ctx.measureText(hintLine).width;

    const longestPx = Math.max(w1, w2);

    // Limit width when zoomed in (prevents super-wide stretched notes)
const MAX_ZOOMED_IN_WIDTH_PX = 900; // tweak as needed

let widthLimitPx = maxInnerPx;

// When zoomed in, reduce width limit
if (scale > 1.3) {
  widthLimitPx = Math.min(widthLimitPx, MAX_ZOOMED_IN_WIDTH_PX);
}

const innerWidthPx = Math.min(
  widthLimitPx,
  Math.max(minInnerPx, longestPx)
);

    const innerWidthWorld = innerWidthPx / scale;

    const lineHeightWorld = lineHeightPx / scale;
    const totalLines = collapsedLines.length; // title + hint
    const heightWorld =
      totalLines * lineHeightWorld + 2 * paddingY;

    n.layoutWidth     = innerWidthWorld + 2 * paddingX;
    n.layoutHeight    = heightWorld;
    n._noteTitleLines = [firstLine];
    n._noteBodyLines  = [];
    n._noteLineHeight = lineHeightWorld;
    n._notePaddingY   = paddingY;

    ctx.restore();
    return;
  }

     // ---------- EXPANDED ----------

  const titleLines = [];
  const bodyLines  = [];

  // same narrower limit for the title when expanded
  const titleMaxPx = maxInnerPx * 0.55;

  let longestPx = wrapInto(
    titleLines,
    titleText || "Note",
    titleMaxPx,
    TITLE_FONT_PX
  );

  if (contentText) {
    const paras = contentText.split(/\n/);
    let firstPara = true;
    for (const para of paras) {
      if (!firstPara) {
        bodyLines.push(""); // blank line between paragraphs
      }
      firstPara = false;
      longestPx = Math.max(
        longestPx,
        wrapInto(bodyLines, para, maxInnerPx, BODY_FONT_PX)
      );
    }
  }

  // ðŸ”½ ZOOM-DEPENDENT LINE CAP
  // When you're zoomed out (small scale), don't let the body become a tower.
  if (scale < 0.85 && bodyLines.length > NOTE_MAX_BODY_LINES_AT_MAX_WIDTH) {
    // keep only the first N lines
    bodyLines.length = NOTE_MAX_BODY_LINES_AT_MAX_WIDTH;

    // add an ellipsis to the last visible body line (if it has any text)
    const lastIdx = bodyLines.length - 1;
    if (lastIdx >= 0) {
      let lastLine = bodyLines[lastIdx].replace(/\s+$/, "");
      if (!lastLine.endsWith("â€¦")) {
        lastLine += " â€¦";
      }
      bodyLines[lastIdx] = lastLine;
    }
  }

  const innerWidthPx = Math.min(
    maxInnerPx,
    Math.max(minInnerPx, longestPx)
  );
  const innerWidthWorld = innerWidthPx / scale;

  const lineHeightWorld = lineHeightPx / scale;
  const totalLines =
    titleLines.length + bodyLines.length + 1; // +1 for hint "(click to collapse)"

  const heightWorld =
    totalLines * lineHeightWorld + 2 * paddingY;

  n.layoutWidth     = innerWidthWorld + 2 * paddingX;
  n.layoutHeight    = heightWorld;
  n._noteTitleLines = titleLines;
  n._noteBodyLines  = bodyLines;
  n._noteLineHeight = lineHeightWorld;
  n._notePaddingY   = paddingY;

  ctx.restore();
}

function measureBookLayout(n) {
  const isOpen = !!n.isOpen;

  if (isOpen) {
    n.layoutWidth  = BOOK_OPEN_WIDTH;
    n.layoutHeight = BOOK_OPEN_HEIGHT;
  } else {
    n.layoutWidth  = BOOK_CLOSED_WIDTH;
    n.layoutHeight = BOOK_CLOSED_HEIGHT;
  }
}

// Draw a single node (all types, including notes)

function drawRoundedNode(n) {
  // --- theme & fonts ---
  const theme = getCurrentTheme();
  let labelFontFamily =
    "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
  if (theme === "fantasyLight" || theme === "fantasyDark") {
    labelFontFamily = "Georgia, 'Times New Roman', serif";
  }

  let fillColor, strokeColor, mainColor, metaColor;

  if (theme === "fantasyLight") {
    fillColor = "#f6ecd1";
    strokeColor = "#b08c3d";
    mainColor = "#3b2f2f";
    metaColor = "rgba(59,47,47,0.7)";
  } else if (theme === "fantasyDark") {
    fillColor = "#24160f";
    strokeColor = "#d7be82";
    mainColor = "#f5e6c4";
    metaColor = "rgba(245,230,196,0.7)";
  } else if (darkMode) {
    fillColor = "#020617";
    strokeColor = "#4b5563";
    mainColor = "#e5e7eb";
    metaColor = "#9ca3af";
  } else {
    fillColor = "#ffffff";
    strokeColor = "#d1d5db";
    mainColor = "#111827";
    metaColor = "#6b7280";
  }

  // ---------- NOTES (handled first, then return) ----------
  if (n.type === "note") {
    // ensure layout
    measureNoteLayout(n);
    const w = n.layoutWidth || NODE_WIDTH;
    const h = n.layoutHeight || NODE_HEIGHT;

    // clamp radius so arcs don't overlap
    let r = NODE_RADIUS;
    const maxR = Math.min(w / 2, h / 2);
    if (r > maxR) r = maxR;

    const left = n.x - w / 2;
    const top = n.y - h / 2;
    const right = n.x + w / 2;
    const bottom = n.y + h / 2;

    // background
    ctx.beginPath();
    ctx.moveTo(left + r, top);
    ctx.lineTo(right - r, top);
    ctx.quadraticCurveTo(right, top, right, top + r);
    ctx.lineTo(right, bottom - r);
    ctx.quadraticCurveTo(right, bottom, right - r, bottom);
    ctx.lineTo(left + r, bottom);
    ctx.quadraticCurveTo(left, bottom, left, bottom - r);
    ctx.lineTo(left, top + r);
    ctx.quadraticCurveTo(left, top, left + r, top);

    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = strokeColor;
    ctx.stroke();

    // text layout data from measureNoteLayout
    const isExpanded      = !!n.isExpanded;
    const titleLines      = n._noteTitleLines || [n.data.title || "Note"];
    const bodyLines       = n._noteBodyLines || [];
    const lineHeightWorld = n._noteLineHeight || (16 / scale);
    const paddingY        = n._notePaddingY   || (12 / scale);
    const boxHeight       = n.layoutHeight    || NODE_HEIGHT;

    let yText = n.y - boxHeight / 2 + paddingY;

    const titleFontPx = 14 / scale;
    const bodyFontPx  = 12 / scale;
    const hintFontPx  = 11 / scale;

    let bodyColor;
    if (theme === "fantasyDark") {
      bodyColor = "rgba(245,230,196,0.70)";
    } else if (theme === "fantasyLight") {
      bodyColor = "rgba(59,47,47,0.65)";
    } else if (darkMode) {
      bodyColor = "rgba(229,231,235,0.75)";
    } else {
      bodyColor = "rgba(17,24,39,0.70)";
    }

    let hintColor;
    if (theme === "fantasyDark") {
      hintColor = "rgba(245,230,196,0.55)";
    } else if (theme === "fantasyLight") {
      hintColor = "rgba(59,47,47,0.55)";
    } else if (darkMode) {
      hintColor = "rgba(229,231,235,0.55)";
    } else {
      hintColor = "rgba(17,24,39,0.45)";
    }

    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    // title
    ctx.font = `${titleFontPx}px ${labelFontFamily}`;
    ctx.fillStyle = mainColor;
    titleLines.forEach(line => {
      ctx.fillText(line, n.x, yText);
      yText += lineHeightWorld;
    });

    // body
    if (isExpanded && bodyLines.length) {
      ctx.font = `${bodyFontPx}px ${labelFontFamily}`;
      ctx.fillStyle = bodyColor;
      bodyLines.forEach(line => {
        ctx.fillText(line, n.x, yText);
        yText += lineHeightWorld;
      });
    }

    // hint
    ctx.font = `italic ${hintFontPx}px ${labelFontFamily}`;
    ctx.fillStyle = hintColor;
    const hintText = isExpanded ? "(click to collapse)" : "(click to expand)";
    ctx.fillText(hintText, n.x, yText);

    return;
  }

  // ---------- BOOKS ----------
  if (n.type === "book") {
    // layout
    measureBookLayout(n);
    const w = n.layoutWidth || BOOK_CLOSED_WIDTH;
    const h = n.layoutHeight || BOOK_CLOSED_HEIGHT;

    const isOpen = !!n.isOpen;
    const left = n.x - w / 2;
    const top = n.y - h / 2;
    const right = n.x + w / 2;
    const bottom = n.y + h / 2;

    const coverColor = n.data.coverColor || BOOK_COVER_COLORS[0];
    const gold = "#d7be82";
    const stitchesColor = "rgba(215,190,130,0.9)";
    const title = n.data.title || "Book";

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // helper for rounded rect
    function roundedRectPath(x1, y1, x2, y2, r) {
      const width = x2 - x1;
      const height = y2 - y1;
      const maxR = Math.min(width / 2, height / 2);
      if (r > maxR) r = maxR;

      ctx.beginPath();
      ctx.moveTo(x1 + r, y1);
      ctx.lineTo(x2 - r, y1);
      ctx.quadraticCurveTo(x2, y1, x2, y1 + r);
      ctx.lineTo(x2, y2 - r);
      ctx.quadraticCurveTo(x2, y2, x2 - r, y2);
      ctx.lineTo(x1 + r, y2);
      ctx.quadraticCurveTo(x1, y2, x1, y2 - r);
      ctx.lineTo(x1, y1 + r);
      ctx.quadraticCurveTo(x1, y1, x1 + r, y1);
    }

    // --- CLOSED BOOK ---
    if (!isOpen) {
      // cover
      roundedRectPath(left, top, right, bottom, NODE_RADIUS);
      ctx.fillStyle = coverColor;
      ctx.fill();
      ctx.lineWidth = 2 / scale;
      ctx.strokeStyle = "#00000033";
      ctx.stroke();

      // stitches inset
      const inset = 10;
      const sLeft = left + inset;
      const sTop = top + inset;
      const sRight = right - inset;
      const sBottom = bottom - inset;

      roundedRectPath(sLeft, sTop, sRight, sBottom, NODE_RADIUS * 0.7);
      ctx.setLineDash([6 / scale, 4 / scale]);
      ctx.strokeStyle = stitchesColor;
      ctx.lineWidth = 1.5 / scale;
      ctx.stroke();
      ctx.setLineDash([]);

      // gold title
      ctx.fillStyle = gold;
      const baseTitlePx = 14 / scale;
      ctx.font = `${baseTitlePx}px ${labelFontFamily}`;
      ctx.fillText(title, n.x, (top + bottom) / 2);

      // tiny hint at bottom
      const hintPx = 9 / scale;
      ctx.font = `italic ${hintPx}px ${labelFontFamily}`;
      ctx.fillText("(click to open)", n.x, bottom - 12 / scale);

      return;
    }

        // --- OPEN BOOK (double spread) ---

    // covers behind pages (left and right halves)
    const midX = n.x;
    const halfW = w / 2;

    // left cover
    roundedRectPath(left, top, midX, bottom, NODE_RADIUS);
    ctx.fillStyle = coverColor;
    ctx.fill();
    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = "#00000055";
    ctx.stroke();

    // right cover
    roundedRectPath(midX, top, right, bottom, NODE_RADIUS);
    ctx.fillStyle = coverColor;
    ctx.fill();
    ctx.strokeStyle = "#00000055";
    ctx.stroke();

    // page rectangle slightly inset so covers are visible
    const pageMargin = 12;
    const pageLeft = left + pageMargin;
    const pageTop = top + pageMargin;
    const pageRight = right - pageMargin;
    const pageBottom = bottom - pageMargin;

    roundedRectPath(pageLeft, pageTop, pageRight, pageBottom, NODE_RADIUS * 0.5);

    let pageColor;
    if (theme === "fantasyLight") {
      pageColor = "#f9f1da";
    } else if (theme === "fantasyDark") {
      pageColor = "#332017";
    } else if (darkMode) {
      pageColor = "#0f172a";
    } else {
      pageColor = "#fdfaf5";
    }

    ctx.fillStyle = pageColor;
    ctx.fill();
    ctx.lineWidth = 1.5 / scale;
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.stroke();

    // central fold
    ctx.beginPath();
    ctx.moveTo(midX, pageTop + 4 / scale);
    ctx.lineTo(midX, pageBottom - 4 / scale);
    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = 1 / scale;
    ctx.stroke();

    // stitching along the inner margin (dotted gold)
    ctx.setLineDash([5 / scale, 4 / scale]);
    ctx.beginPath();
    ctx.moveTo(midX - 6 / scale, pageTop + 6 / scale);
    ctx.lineTo(midX - 6 / scale, pageBottom - 6 / scale);
    ctx.moveTo(midX + 6 / scale, pageTop + 6 / scale);
    ctx.lineTo(midX + 6 / scale, pageBottom - 6 / scale);
    ctx.strokeStyle = stitchesColor;
    ctx.lineWidth = 1 / scale;
    ctx.stroke();
    ctx.setLineDash([]);

    // book title at top center (gold)
    const titlePx = 13 / scale;
    ctx.font = `${titlePx}px ${labelFontFamily}`;
    ctx.fillStyle = gold;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(title, n.x, pageTop + 6 / scale);

    // page number (no "(edit in sidebar)" anymore)
    const currIndex = Math.max(0, Math.min((n.data.currentPage ?? 0), BOOK_MAX_PAGES - 1));
    const pageLabel = `Page ${currIndex + 1} / ${BOOK_MAX_PAGES}`;
    const hintPx = 9 / scale;
    ctx.font = `italic ${hintPx}px ${labelFontFamily}`;
    ctx.fillStyle = metaColor;
    ctx.textAlign = "left";
    ctx.fillText(pageLabel, pageLeft + 8 / scale, pageBottom - 14 / scale);

    // ðŸ”¹ Two separate page text boxes, left-aligned
    if (Array.isArray(n.data.pages)) {
      // left page index = currentPage
      const leftIdx = currIndex;
      // right page index = currentPage + 1 (clamped)
      const rightIdx = Math.min(leftIdx + 1, BOOK_MAX_PAGES - 1);

      const leftText  = n.data.pages[leftIdx]  || "";
      const rightText = n.data.pages[rightIdx] || "";

      // helper to wrap text
      function wrapLines(text, maxWidthPx, maxLines) {
        ctx.textBaseline = "top";
        const lines = [];
        if (!text) return lines;
        const words = text.split(/\s+/);
        let current = "";

        function pushLine(line) {
          if (line !== "") lines.push(line);
        }

        for (const wWord of words) {
          const test = current ? current + " " + wWord : wWord;
          if (ctx.measureText(test).width <= maxWidthPx || !current) {
            current = test;
          } else {
            pushLine(current);
            current = wWord;
          }
        }
        if (current) pushLine(current);

        if (lines.length > maxLines) {
          lines.length = maxLines;
          lines[maxLines - 1] = lines[maxLines - 1] + " â€¦";
        }
        return lines;
      }

      // text styling
      const bodyPx = 11 / scale;
      ctx.font = `${bodyPx}px ${labelFontFamily}`;
      ctx.fillStyle = (
        theme === "fantasyDark" ? "rgba(245,230,196,0.85)" :
        theme === "fantasyLight" ? "rgba(59,47,47,0.85)" :
        darkMode ? "rgba(229,231,235,0.9)" :
        "rgba(17,24,39,0.8)"
      );
      ctx.textAlign = "left";

      // geometry for each pageâ€™s text box
      const innerMargin = 12 / scale;
      const textTop = pageTop + 26 / scale;
      const lineHeightWorld = 14 / scale;
      const lineHeightPx = lineHeightWorld * scale;

      // LEFT PAGE BOX
      const leftBoxLeft = pageLeft + innerMargin;
      const leftBoxRight = midX - innerMargin;
      const leftBoxWidthWorld = leftBoxRight - leftBoxLeft;
      const leftMaxWidthPx = leftBoxWidthWorld * scale;

      const leftLines = wrapLines(leftText, leftMaxWidthPx, 10);
      let yLeft = textTop;
      leftLines.forEach(line => {
        ctx.fillText(line, leftBoxLeft, yLeft);
        yLeft += lineHeightPx;
      });

      // RIGHT PAGE BOX
      const rightBoxLeft = midX + innerMargin;
      const rightBoxRight = pageRight - innerMargin;
      const rightBoxWidthWorld = rightBoxRight - rightBoxLeft;
      const rightMaxWidthPx = rightBoxWidthWorld * scale;

      const rightLines = wrapLines(rightText, rightMaxWidthPx, 10);
      let yRight = textTop;
      rightLines.forEach(line => {
        ctx.fillText(line, rightBoxLeft, yRight);
        yRight += lineHeightPx;
      });
    }

    return;
  }

  // ---------- EVERYONE ELSE (character, location, item, default) ----------

  // ensure layout size
  n.layoutWidth = NODE_WIDTH;
  n.layoutHeight = NODE_HEIGHT;

  const w = n.layoutWidth || NODE_WIDTH;
  const h = n.layoutHeight || NODE_HEIGHT;

  // clamp radius
  let r = NODE_RADIUS;
  const maxR = Math.min(w / 2, h / 2);
  if (r > maxR) r = maxR;

  const left = n.x - w / 2;
  const top = n.y - h / 2;
  const right = n.x + w / 2;
  const bottom = n.y + h / 2;

  // outer rounded rect
  ctx.beginPath();
  ctx.moveTo(left + r, top);
  ctx.lineTo(right - r, top);
  ctx.quadraticCurveTo(right, top, right, top + r);
  ctx.lineTo(right, bottom - r);
  ctx.quadraticCurveTo(right, bottom, right - r, bottom);
  ctx.lineTo(left + r, bottom);
  ctx.quadraticCurveTo(left, bottom, left, bottom - r);
  ctx.lineTo(left, top + r);
  ctx.quadraticCurveTo(left, top, left + r, top);

  ctx.fillStyle = fillColor;
  ctx.fill();
  ctx.lineWidth = 2 / scale;
  ctx.strokeStyle = strokeColor;
  ctx.stroke();

  const maxWidth = w - 20;
  const zoomedOut = scale < 0.85;

  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  function wrapAndTruncateText(text, maxWidthPx, maxLinesLocal) {
    ctx.font = `${13 / scale}px ${labelFontFamily}`;

    if (!text) return [];

    const words = text.split(/\s+/);
    const lines = [];
    let current = "";

    function pushLine(line) {
      if (line !== "") lines.push(line);
    }

    function breakLongWord(word) {
      let part = "";
      for (const ch of word) {
        const test = part + ch;
        if (ctx.measureText(test).width <= maxWidthPx || !part) {
          part = test;
        } else {
          lines.push(part);
          part = ch;
        }
      }
      if (part) lines.push(part);
    }

    for (const word of words) {
      const wordWidth = ctx.measureText(word).width;
      if (wordWidth > maxWidthPx) {
        if (current) {
          pushLine(current);
          current = "";
        }
        breakLongWord(word);
        continue;
      }

      const test = current ? current + " " + word : word;
      if (ctx.measureText(test).width <= maxWidthPx || !current) {
        current = test;
      } else {
        pushLine(current);
        current = word;
      }
    }
    if (current) pushLine(current);

    if (lines.length <= maxLinesLocal) return lines;

    const truncated = lines.slice(0, maxLinesLocal);
    let last = truncated[maxLinesLocal - 1];

    while (last.length > 0 && ctx.measureText(last + "â€¦").width > maxWidthPx) {
      last = last.slice(0, -1);
    }

    truncated[maxLinesLocal - 1] = last + "â€¦";
    return truncated;
  }

  function shrinkSingleLine(text, baseFontPx, minFontPx, maxWidthPx) {
    if (!text) return { text: "", fontPx: baseFontPx };

    let fontPx = baseFontPx;
    ctx.font = `${fontPx}px ${labelFontFamily}`;

    if (ctx.measureText(text).width <= maxWidthPx) {
      return { text, fontPx };
    }

    while (fontPx > minFontPx) {
      fontPx -= 1;
      ctx.font = `${fontPx}px ${labelFontFamily}`;
      if (ctx.measureText(text).width <= maxWidthPx) {
        return { text, fontPx };
      }
    }

    let t = text;
    const ell = "â€¦";
    while (t.length > 1 && ctx.measureText(t + ell).width > maxWidthPx) {
      t = t.slice(0, -1);
    }
    return { text: t + ell, fontPx };
  }

  function drawNameOnly(label) {
    const text = label || nodeDisplayLabel(n);
    const baseFontSize = 13 / scale;
    const minFontSize  = 9 / scale;
    const fitted = shrinkSingleLine(text, baseFontSize, minFontSize, maxWidth);
    const centerY = n.y;

    ctx.font = `${fitted.fontPx}px ${labelFontFamily}`;
    ctx.fillStyle = mainColor;
    ctx.fillText(fitted.text, n.x, centerY);
  }

  // characters
  if (n.type === "character") {
    const name    = n.data.name    || "Character";
    const species = n.data.species || "";
    const gender  = n.data.gender  || "";

    if (zoomedOut) {
      drawNameOnly(name);
      return;
    }

    const baseNameFontSize = 15 / scale;
    const minNameFontSize  = 10 / scale;
    const metaFontSize     = 10 / scale;
    const metaLineHeight   = 13 / scale;

    const fitted = shrinkSingleLine(
      name,
      baseNameFontSize,
      minNameFontSize,
      maxWidth
    );
    const nameLineHeight = fitted.fontPx * 1.15;

    const speciesLines = species ? wrapAndTruncateText(species, maxWidth, 2) : [];
    const genderLines  = gender  ? wrapAndTruncateText(gender,  maxWidth, 1) : [];

    const totalHeight =
      nameLineHeight +
      speciesLines.length * metaLineHeight +
      genderLines.length * metaLineHeight;

    let yText = n.y - totalHeight / 2;

    ctx.font = `${fitted.fontPx}px ${labelFontFamily}`;
    ctx.fillStyle = mainColor;
    ctx.fillText(fitted.text, n.x, yText);
    yText += nameLineHeight;

    ctx.font = `italic ${metaFontSize}px ${labelFontFamily}`;
    ctx.fillStyle = metaColor;
    speciesLines.forEach(line => {
      ctx.fillText(line, n.x, yText);
      yText += metaLineHeight;
    });

    ctx.font = `${metaFontSize}px ${labelFontFamily}`;
    ctx.fillStyle = metaColor;
    genderLines.forEach(line => {
      ctx.fillText(line, n.x, yText);
      yText += metaLineHeight;
    });

    return;
  }

  // locations
  if (n.type === "location") {
    const name = n.data.name || "Location";

    if (zoomedOut) {
      drawNameOnly(name);
      return;
    }

    let rawCat = n.data.category || "";
    let prettyType = "";
    if (rawCat === "custom" && n.data.customCategory) {
      prettyType = n.data.customCategory;
    } else if (rawCat) {
      prettyType = rawCat.charAt(0).toUpperCase() + rawCat.slice(1);
    }

    const baseNameFontSize = 13 / scale;
    const minNameFontSize  = 9 / scale;
    const typeFontSize     = 11 / scale;
    const typeLineHeight   = 13 / scale;

    const fitted = shrinkSingleLine(
      name,
      baseNameFontSize,
      minNameFontSize,
      maxWidth
    );
    const nameLineHeight = fitted.fontPx * 1.15;

    const typeLines = prettyType
      ? wrapAndTruncateText(prettyType, maxWidth, 2)
      : [];

    const totalHeight =
      nameLineHeight +
      typeLines.length * typeLineHeight;

    let yText = n.y - totalHeight / 2;

    ctx.font = `${fitted.fontPx}px ${labelFontFamily}`;
    ctx.fillStyle = mainColor;
    ctx.fillText(fitted.text, n.x, yText);
    yText += nameLineHeight;

    if (typeLines.length) {
      ctx.font = `italic ${typeFontSize}px ${labelFontFamily}`;
      ctx.fillStyle = metaColor;
      typeLines.forEach(line => {
        ctx.fillText(line, n.x, yText);
        yText += typeLineHeight;
      });
    }

    return;
  }

  // items
  if (n.type === "item") {
    const name      = n.data.name     || "Item";
    const typeLabel = n.data.itemType || "";

    if (zoomedOut) {
      drawNameOnly(name);
      return;
    }

    const baseNameFontSize = 13 / scale;
    const minNameFontSize  = 9 / scale;
    const typeFontSize     = 11 / scale;
    const typeLineHeight   = 13 / scale;

    const fitted = shrinkSingleLine(
      name,
      baseNameFontSize,
      minNameFontSize,
      maxWidth
    );
    const nameLineHeight = fitted.fontPx * 1.15;

    const typeLines = typeLabel
      ? wrapAndTruncateText(typeLabel, maxWidth, 2)
      : [];

    const totalHeight =
      nameLineHeight +
      typeLines.length * typeLineHeight;

    let yText = n.y - totalHeight / 2;

    ctx.font = `${fitted.fontPx}px ${labelFontFamily}`;
    ctx.fillStyle = mainColor;
    ctx.fillText(fitted.text, n.x, yText);
    yText += nameLineHeight;

    if (typeLines.length) {
      ctx.font = `italic ${typeFontSize}px ${labelFontFamily}`;
      ctx.fillStyle = metaColor;
      typeLines.forEach(line => {
        ctx.fillText(line, n.x, yText);
        yText += typeLineHeight;
      });
    }

    return;
  }

  // default node type
  const label = nodeDisplayLabel(n);

  if (zoomedOut) {
    drawNameOnly(label);
    return;
  }

  const baseFontSize = 13 / scale;
  const minFontSize  = 9 / scale;
  const fitted = shrinkSingleLine(
    label,
    baseFontSize,
    minFontSize,
    maxWidth
  );
  const lineHeight = fitted.fontPx * 1.15;

  const totalHeightDefault = lineHeight;
  const startY = n.y - totalHeightDefault / 2;

  ctx.font = `${fitted.fontPx}px ${labelFontFamily}`;
  ctx.fillStyle = mainColor;
  ctx.fillText(fitted.text, n.x, startY);
}




    function drawBubbles() {
  const theme = getCurrentTheme();
  let strokeColor, labelColor;

  if (theme === "fantasyLight") {
    strokeColor = "#8b5a30";
    labelColor = "#3b2f2f";
  } else if (theme === "fantasyDark") {
    strokeColor = "#f5e6c4";
    labelColor = "#f5e6c4";
  } else if (darkMode) {
    strokeColor = "#4b5563";
    labelColor = "#e5e7eb";
  } else {
    strokeColor = "#9ca3af";
    labelColor = "#111827";
  }

  bubbles.forEach(b => {
    const R = b.radius || BUBBLE_BASE_RADIUS;

    // --- dotted ring ---
    ctx.beginPath();
    ctx.setLineDash([20 / scale, 10 / scale]);  // â† dotted
    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = strokeColor;
    ctx.arc(b.x, b.y, R, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);                        // â† reset for other drawing

    // label
    const label = `${b.name || "Bubble"} (${b.nodeCount || 0})`;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";

    let labelFontFamily =
      "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
    if (theme === "fantasyLight" || theme === "fantasyDark") {
      labelFontFamily = "Georgia, 'Times New Roman', serif";
    }
    ctx.font = `${13 / scale}px ${labelFontFamily}`;
    ctx.fillStyle = labelColor;

    ctx.fillText(label, b.x, b.y - R - 10 / scale);
  });
}


    // Explosion visuals/physics
    function spawnExplosionGif(screenX, screenY) {
      const img = document.createElement("img");
      img.className = "explosion-gif";
      img.src =
        "https://www.spriters-resource.com/media/asset_icons/159/162192.gif?t=10" +
        performance.now();
      img.style.left = screenX + "px";
      img.style.top = screenY + "px";
      document.body.appendChild(img);
      setTimeout(() => img.remove(), 1200);
    }

    function playExplosionSound() {
      const audio = document.getElementById("explosionSound");
      if (!audio) return;
      try {
        audio.currentTime = 0;
        audio.play().catch(() => {});
      } catch (e) {
        console.error("Explosion sound error", e);
      }
    }

    function triggerShockwave(worldX, worldY) {
  const MAX_RADIUS = 600;
  const FORCE = 2400;

  // Nodes
  nodes.forEach(n => {
    let dx = n.x - worldX;
    let dy = n.y - worldY;
    let dist = Math.hypot(dx, dy);

    if (!dist) dist = 0.001;
    if (dist > MAX_RADIUS) return;

    const falloff = 1 - dist / MAX_RADIUS;
    const strength = FORCE * falloff;

    dx /= dist;
    dy /= dist;

    n.vx += dx * strength;
    n.vy += dy * strength;
  });

  // Bubbles
  bubbles.forEach(b => {
    let dx = b.x - worldX;
    let dy = b.y - worldY;
    let dist = Math.hypot(dx, dy);

    if (!dist) dist = 0.001;
    if (dist > MAX_RADIUS) return;

    const falloff = 1 - dist / MAX_RADIUS;
    const strength = FORCE * falloff * 0.7; // a bit gentler than nodes

    dx /= dist;
    dy /= dist;

    b.vx += dx * strength;
    b.vy += dy * strength;
  });
}


    function triggerExplosion(worldX, worldY, screenX, screenY) {
      spawnExplosionGif(screenX, screenY);
      playExplosionSound();
      triggerShockwave(worldX, worldY);
    }

    function drawEdges() {
  const groups = buildEdgeGroups();
  ctx.lineWidth = 4 / scale;

  // Tiny offsets so everything stays nicely bunched
  const laneBase   = 12 / scale; // distance between forward and backward lanes
  const laneSpread = 12 / scale; // spread for multiple edges *within* a lane

  for (const key in groups) {
    const bundle = groups[key];
    const [minIdStr, maxIdStr] = key.split("-");
    const minId = Number(minIdStr);
    const maxId = Number(maxIdStr);

    const nodeA = getNodeById(minId);
    const nodeB = getNodeById(maxId);
    if (!nodeA || !nodeB) continue;

    // Canonical line from minId -> maxId
    let baseAx = nodeA.x;
    let baseAy = nodeA.y;
    let baseBx = nodeB.x;
    let baseBy = nodeB.y;

    let dx = baseBx - baseAx;
    let dy = baseBy - baseAy;
    let dist = Math.hypot(dx, dy) || 1;
    dx /= dist;
    dy /= dist;

    // Perpendicular
    const perpX = -dy;
    const perpY = dx;

    // We draw lanes in this order:
    const laneDefs = [
      { kind: "both",     side: 0 },  // centre
      { kind: "forward",  side: 1 },  // tiny offset one way
      { kind: "backward", side: -1 }  // tiny offset the other way
    ];

    for (const lane of laneDefs) {
      const arr = bundle[lane.kind];
      if (!arr || arr.length === 0) continue;

      const groupSize = arr.length;
      const centerIndex = (groupSize - 1) / 2;

      for (let gi = 0; gi < arr.length; gi++) {
        const edgeIndex = arr[gi];
        const e = edges[edgeIndex];
        const fromNode = getNodeById(e.fromId);
        const toNode = getNodeById(e.toId);
        if (!fromNode || !toNode) continue;

        // Main lane offset (different for forward/backward/both)
        const laneOffset = lane.side * laneBase;
        // Small spreading inside each lane
        const internalOffset = (gi - centerIndex) * laneSpread;
        const offsetWorld = laneOffset + internalOffset;

        const offX = perpX * offsetWorld;
        const offY = perpY * offsetWorld;

        let ax = fromNode.x + offX;
        let ay = fromNode.y + offY;
        let bx = toNode.x + offX;
        let by = toNode.y + offY;

        const color = edgeColors[e.type] || "#4b5563";
        ctx.strokeStyle = color;

        // Line
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();

        // Middle decoration: arrow or dot
        const mx = (ax + bx) / 2;
        const my = (ay + by) / 2;

        if (e.direction === "both") {
          const radius = 7 / scale;
          ctx.beginPath();
          ctx.arc(mx, my, radius, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
        } else {
          const arrowSize = 10 / scale;
          const vx = bx - ax;
          const vy = by - ay;
          const vlen = Math.hypot(vx, vy) || 1;
          const ux = vx / vlen;
          const uy = vy / vlen;

          const tipX = mx + ux * arrowSize;
          const tipY = my + uy * arrowSize;
          const backX = mx - ux * arrowSize;
          const backY = my - uy * arrowSize;

          const leftX = backX + (-uy) * arrowSize * 0.6;
          const leftY = backY + (ux) * arrowSize * 0.6;
          const rightX = backX + (uy) * arrowSize * 0.6;
          const rightY = backY + (-ux) * arrowSize * 0.6;

          ctx.beginPath();
          ctx.moveTo(tipX, tipY);
          ctx.lineTo(leftX, leftY);
          ctx.lineTo(rightX, rightY);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
      }
    }
  }
}


    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const theme = getCurrentTheme();
      let bgColor;

      if (theme === "fantasyLight") {
        bgColor = "#f3e8c8";
      } else if (theme === "fantasyDark") {
        bgColor = "#1b130e";
      } else {
        bgColor = darkMode ? "#020617" : "#ffffff";
      }

      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.setTransform(scale, 0, 0, scale, panX, panY);

      drawGrid();
      drawBubbles();
      drawEdges();
      nodes.forEach(n => drawRoundedNode(n));
    }

    function applyBubbleShellForces() {
  bubbles.forEach(b => {
    const R = b.radius || BUBBLE_BASE_RADIUS;

    nodes.forEach(n => {
      let dx = n.x - b.x;
      let dy = n.y - b.y;
      let dist = Math.hypot(dx, dy) || 0.001;

      // Distance from the ring
      const distFromShell = Math.abs(dist - R);

      // Only apply force when close to the ring
      if (distFromShell > BUBBLE_WALL_THICKNESS) return;

      // Strength fades the farther from the ring
      const t = 1 - distFromShell / BUBBLE_WALL_THICKNESS;

      const outwardX = dx / dist;
      const outwardY = dy / dist;

      // outside â†’ push outward; inside â†’ push inward
      const sign = dist > R ? 1 : -1;

      const f = BUBBLE_WALL_FORCE * t;

      n.vx += outwardX * sign * f;
      n.vy += outwardY * sign * f;
    });
  });
}


    function physics() {
      for (let n of nodes) {
        if (typeof n.vx !== "number") n.vx = 0;
        if (typeof n.vy !== "number") n.vy = 0;
      }
      bubbles.forEach(b => {
        if (typeof b.vx !== "number") b.vx = 0;
        if (typeof b.vy !== "number") b.vy = 0;
        if (typeof b.radius !== "number") b.radius = BUBBLE_BASE_RADIUS;
      });

      // ðŸ”¹ Make sure every node has a rectangular layout
nodes.forEach(n => {
  if (n.type === "note") {
    // notes can be large; measure actual size
    measureNoteLayout(n);
  } else if (n.type === "book") {
    // books have their own closed/open footprint
    measureBookLayout(n);
  } else {
    // default size for non-note/non-book nodes
    n.layoutWidth  = NODE_WIDTH;
    n.layoutHeight = NODE_HEIGHT;
  }
});


      // Update bubble sizes/counts first
      updateBubbleRadiiAndCounts();

      // --- bubble-bubble repulsion ---
for (let i = 0; i < bubbles.length; i++) {
  for (let j = i + 1; j < bubbles.length; j++) {
    const a = bubbles[i];
    const b = bubbles[j];

    const Ra = a.radius || BUBBLE_BASE_RADIUS;
    const Rb = b.radius || BUBBLE_BASE_RADIUS;
    const minDist = Ra + Rb + 40; // padding between bubbles

    let dx = b.x - a.x;
    let dy = b.y - a.y;
    let dist = Math.hypot(dx, dy) || 0.001;

    if (dist >= minDist) continue;

    const overlap = minDist - dist;
    const strength = 0.02 * overlap; // tweak this

    dx /= dist;
    dy /= dist;

    // push them apart
    a.vx -= dx * strength;
    a.vy -= dy * strength;
    b.vx += dx * strength;
    b.vy += dy * strength;
  }
}


            // ðŸ”¹ Nodeâ€“node repulsion
// - Note nodes: rectangular hitboxes (so big notes push properly)
// - Regular nodes: original radial repulsion using BUBBLE_RADIUS/BUBBLE_FORCE

const NODE_MARGIN = 40;        // extra spacing between note rectangles
const NODE_RECT_FORCE = 0.08;  // strength of the push for notes

for (let i = 0; i < nodes.length; i++) {
  const a = nodes[i];

  for (let j = i + 1; j < nodes.length; j++) {
    const b = nodes[j];

    const isNoteA = a.type === "note";
    const isNoteB = b.type === "note";

    // === CASE 1: at least one is a note â†’ rectangular hitboxes ===
    if (isNoteA || isNoteB) {
      const aW = (a.layoutWidth  || NODE_WIDTH);
      const aH = (a.layoutHeight || NODE_HEIGHT);
      const bW = (b.layoutWidth  || NODE_WIDTH);
      const bH = (b.layoutHeight || NODE_HEIGHT);

      const aHalfW = aW / 2;
      const aHalfH = aH / 2;
      const bHalfW = bW / 2;
      const bHalfH = bH / 2;

      const dx = b.x - a.x;
      const dy = b.y - a.y;

      const overlapX =
        aHalfW + bHalfW + NODE_MARGIN - Math.abs(dx);
      const overlapY =
        aHalfH + bHalfH + NODE_MARGIN - Math.abs(dy);

      if (overlapX <= 0 || overlapY <= 0) continue;

      if (overlapX < overlapY) {
        // Separate along X
        const dirX = dx === 0 ? (Math.random() < 0.5 ? -1 : 1) : Math.sign(dx);
        const fx = dirX * overlapX * NODE_RECT_FORCE;
        a.vx -= fx;
        b.vx += fx;
      } else {
        // Separate along Y
        const dirY = dy === 0 ? (Math.random() < 0.5 ? -1 : 1) : Math.sign(dy);
        const fy = dirY * overlapY * NODE_RECT_FORCE;
        a.vy -= fy;
        b.vy += fy;
      }
    }

    // === CASE 2: both are regular nodes â†’ original radial repulsion ===
    else {
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.hypot(dx, dy) || 0.001;

      if (dist >= BUBBLE_RADIUS) continue;

      const falloff = (BUBBLE_RADIUS - dist) / BUBBLE_RADIUS;
      const force = BUBBLE_FORCE * falloff;

      dx /= dist;
      dy /= dist;

      a.vx -= dx * force;
      a.vy -= dy * force;
      b.vx += dx * force;
      b.vy += dy * force;
    }
  }
}



     // Edge springs â€“ longer if nodes (esp. notes) are bigger
const springPairs = {};
edges.forEach(e => {
  const key =
    e.fromId < e.toId
      ? e.fromId + "-" + e.toId
      : e.toId + "-" + e.fromId;
  springPairs[key] = { fromId: e.fromId, toId: e.toId };
});

for (const key in springPairs) {
  const e = springPairs[key];
  const a = getNodeById(e.fromId);
  const b = getNodeById(e.toId);
  if (!a || !b) continue;

  // Make sure notes have current size
  if (a.type === "note") measureNoteLayout(a);
  if (b.type === "note") measureNoteLayout(b);

  const aW = a.layoutWidth  || NODE_WIDTH;
  const bW = b.layoutWidth  || NODE_WIDTH;
  const aH = a.layoutHeight || NODE_HEIGHT;
  const bH = b.layoutHeight || NODE_HEIGHT;

  // Treat each node like it has a "radius" based on its size
  const baseRadius = NODE_WIDTH / 2; // default node
  const aRadius = Math.max(aW, aH) / 2;
  const bRadius = Math.max(bW, bH) / 2;

  // Extra spacing needed beyond the default spring length
  const extraSpacing =
    Math.max(0, aRadius - baseRadius) +
    Math.max(0, bRadius - baseRadius);

  const desiredLength = SPRING_LENGTH + extraSpacing;

  let dx = b.x - a.x;
  let dy = b.y - a.y;
  let dist = Math.hypot(dx, dy) || 0.001;

  const diff = dist - desiredLength;
  const force = SPRING_STRENGTH * diff;

  dx /= dist;
  dy /= dist;

  const fx = dx * force;
  const fy = dy * force;

  a.vx += fx;
  a.vy += fy;
  b.vx -= fx;
  b.vy -= fy;
}


      // Bubble shell forces on nodes
      applyBubbleShellForces();

      // Integrate nodes
      for (let n of nodes) {
        if (draggingNode === n && currentMode === MODES.MOVE) {
          n.x += (dragTarget.x - n.x) * 0.25;
          n.y += (dragTarget.y - n.y) * 0.25;
          n.vx = 0;
          n.vy = 0;
        } else {
          n.x += n.vx * 0.08;
          n.y += n.vy * 0.08;
        }

        n.vx *= DAMPING;
        n.vy *= DAMPING;
      }

      // Integrate bubbles
bubbles.forEach(b => {
  if (draggingBubble === b && currentMode === MODES.MOVE) {
    // Smooth follow toward the drag target, same style as nodes
    b.x += (bubbleDragTarget.x - b.x) * 0.25;
    b.y += (bubbleDragTarget.y - b.y) * 0.25;
    b.vx = 0;
    b.vy = 0;
  } else {
    b.x += b.vx * 0.08;
    b.y += b.vy * 0.08;
    b.vx *= DAMPING;
    b.vy *= DAMPING;
  }
});

      draw();
      requestAnimationFrame(physics);
    }
    
function sidebarSearchHTML() {
  return `
    <div class="search-block">
      <div class="field-group">
        <label for="sidebar-search">Search elements</label>
        <input id="sidebar-search" placeholder="Type a name or title...">
      </div>
      <div id="sidebar-search-results" class="search-results"></div>
    </div>
  `;
}

function setupSidebarSearch() {
  const input = document.getElementById("sidebar-search");
  const resultsEl = document.getElementById("sidebar-search-results");
  if (!input || !resultsEl) return;

  function renderResults() {
    const q = input.value.trim().toLowerCase();
    resultsEl.innerHTML = "";
    if (!q) return;

            const matches = nodes.filter(n => {
      if (n.type === "character") {
        const name = (n.data.name || "").toLowerCase();
        return name.includes(q);
      }
      if (n.type === "location") {
        const name = (n.data.name || "").toLowerCase();
        return name.includes(q);
      }
      if (n.type === "item") {
        const name = (n.data.name || "").toLowerCase();
        const type = (n.data.itemType || "").toLowerCase();
        return name.includes(q) || type.includes(q);
      }
      if (n.type === "note") {
        const title = (n.data.title || "").toLowerCase();
        const content = (n.data.content || "").toLowerCase();
        return title.includes(q) || content.includes(q);
      }
      if (n.type === "book") {
        const title = (n.data.title || "").toLowerCase();
        let pagesText = "";
        if (Array.isArray(n.data.pages)) {
          pagesText = n.data.pages.join(" ").toLowerCase();
        }
        return title.includes(q) || pagesText.includes(q);
      }
      return false;
    });


    matches.forEach(n => {
      const div = document.createElement("div");
      div.className = "search-result";

            let displayName = "";
      let typeLabel = "";

      if (n.type === "character") {
        displayName = n.data.name || `Character #${n.id}`;
        typeLabel = "Character";
      } else if (n.type === "location") {
        displayName = n.data.name || `Location #${n.id}`;
        typeLabel = "Location";
      } else if (n.type === "item") {
        displayName = n.data.name || `Item #${n.id}`;
        typeLabel = "Item";
      } else if (n.type === "note") {
        displayName = n.data.title || `Note #${n.id}`;
        typeLabel = "Note";
      } else if (n.type === "book") {
        displayName = n.data.title || `Book #${n.id}`;
        typeLabel = "Book";
      }



      div.textContent = `${displayName} (${typeLabel})`;

      div.addEventListener("click", () => {
        selectedNode = n;
        selectedBubble = null;

        // centre view on the element
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        panX = cx - n.x * scale;
        panY = cy - n.y * scale;

        renderSidebar();
      });

      resultsEl.appendChild(div);
    });
  }

  input.addEventListener("input", renderResults);
}


    function renderSidebar() {
  // === NOTHING SELECTED ===
  if (!selectedNode && !selectedBubble) {
    sidebar.innerHTML = `
      <div>
        <h2>No node selected</h2>
        <p>Switch to <strong>Edit âœŽ</strong> mode and click a node or bubble to see its details here.</p>
        <h3>Connection Types</h3>
        <div class="connection-legend">
          <div class="legend-item"><span class="legend-color" style="background:#2196f3;"></span>friends</div>
          <div class="legend-item"><span class="legend-color" style="background:#ffd335;"></span>family</div>
          <div class="legend-item"><span class="legend-color" style="background:#e68de0;"></span>romantic</div>
          <div class="legend-item"><span class="legend-color" style="background:#f44336;"></span>enemy</div>
          <div class="legend-item"><span class="legend-color" style="background:#bdbdbd;"></span>neutral</div>
          <div class="legend-item"><span class="legend-color" style="background:#000000;"></span>traitor</div>
          <div class="legend-item"><span class="legend-color" style="background:#8b5cf6;"></span>ex-relationship</div>
          <div class="legend-item"><span class="legend-color" style="background:#ffeb3b;"></span>parent/caretaker</div>
          <div class="legend-item"><span class="legend-color" style="background:#4caf50;"></span>coworkers</div>
        </div>
      </div>
      ${sidebarSearchHTML()}
    `;
    setupSidebarSearch();
    return;
  }

  // === BUBBLE SELECTED ===
  if (selectedBubble) {
    const count = countNodesInBubble(selectedBubble);
    sidebar.innerHTML = `
      <div>
        <div class="pill">Bubble</div>
        <h2>${selectedBubble.name || "Bubble"}</h2>
        <p>Nodes inside: ${count}</p>

        <div class="field-group">
          <label for="bubble-name">Name</label>
          <input id="bubble-name" value="${selectedBubble.name || ""}">
        </div>
      </div>
      ${sidebarSearchHTML()}
    `;

    document.getElementById("bubble-name").addEventListener("input", e => {
      selectedBubble.name = e.target.value;
    });

    setupSidebarSearch();
    return;
  }

  // === CHARACTER SELECTED ===
  if (selectedNode.type === "character") {
    sidebar.innerHTML = `
      <div>
        <div class="pill">Character</div>
        <h2>${selectedNode.data.name || "Character"}</h2>

        <div class="field-group">
          <label for="char-name">Name</label>
          <input id="char-name" value="${selectedNode.data.name || ""}">
        </div>
        <div class="field-group">
  <label for="char-age">Age</label>
  <input
    id="char-age"
    type="text"
    inputmode="numeric"
    pattern="[0-9]*"
    value="${selectedNode.data.age || ""}"
  >
</div>
        <div class="field-group">
          <label for="char-dob">Date of Birth</label>
          <input id="char-dob" value="${selectedNode.data.dob || ""}">
        </div>
        <div class="field-group">
          <label for="char-species">Species</label>
          <input id="char-species" value="${selectedNode.data.species || ""}">
        </div>
        <div class="field-group">
          <label for="char-height">Height</label>
          <input id="char-height" value="${selectedNode.data.height || ""}">
        </div>
        <div class="field-group">
          <label for="char-weight">Weight</label>
          <input id="char-weight" value="${selectedNode.data.weight || ""}">
        </div>
        <div class="field-group">
          <label for="char-gender">Gender</label>
          <input id="char-gender" value="${selectedNode.data.gender || ""}">
        </div>
      </div>
      ${sidebarSearchHTML()}
    `;

    document.getElementById("char-name").addEventListener("input", e => {
      selectedNode.data.name = e.target.value;
    });
    document.getElementById("char-age").addEventListener("input", e => {
  // strip everything that isn't 0â€“9
  const cleaned = e.target.value.replace(/\D/g, "");
  e.target.value = cleaned;
  selectedNode.data.age = cleaned;
});
    document.getElementById("char-dob").addEventListener("input", e => {
      selectedNode.data.dob = e.target.value;
    });
    document.getElementById("char-species").addEventListener("input", e => {
      selectedNode.data.species = e.target.value;
    });
    document.getElementById("char-height").addEventListener("input", e => {
      selectedNode.data.height = e.target.value;
    });
    document.getElementById("char-weight").addEventListener("input", e => {
      selectedNode.data.weight = e.target.value;
    });
    document.getElementById("char-gender").addEventListener("input", e => {
      selectedNode.data.gender = e.target.value;
    });

    setupSidebarSearch();
  }

  // === LOCATION SELECTED ===
  else if (selectedNode.type === "location") {
  sidebar.innerHTML = `
    <div>
      <div class="pill">Location</div>
      <h2>${selectedNode.data.name || "Location"}</h2>

      <div class="field-group">
        <label for="loc-name">Name</label>
        <input id="loc-name" value="${selectedNode.data.name || ""}">
      </div>

      <div class="field-group">
        <label for="loc-category">Type</label>
        <select id="loc-category">
          <option value="village"${selectedNode.data.category === "village" ? " selected" : ""}>Village</option>
          <option value="town"${selectedNode.data.category === "town" ? " selected" : ""}>Town</option>
          <option value="city"${selectedNode.data.category === "city" ? " selected" : ""}>City</option>
          <option value="nature"${selectedNode.data.category === "nature" ? " selected" : ""}>Nature</option>
          <option value="forest"${selectedNode.data.category === "forest" ? " selected" : ""}>Forest</option>
          <option value="custom"${selectedNode.data.category === "custom" ? " selected" : ""}>Custom</option>
        </select>
      </div>

      <div
        class="field-group"
        id="loc-custom-wrapper"
        style="display:${selectedNode.data.category === 'custom' ? 'block' : 'none'}"
      >
        <label for="loc-custom">Custom type</label>
        <input id="loc-custom" value="${selectedNode.data.customCategory || ""}">
      </div>
    </div>
    ${sidebarSearchHTML()}
  `;

  document.getElementById("loc-name").addEventListener("input", e => {
    selectedNode.data.name = e.target.value;
  });

  const catSelect = document.getElementById("loc-category");
  const customWrapper = document.getElementById("loc-custom-wrapper");
  const customInput = document.getElementById("loc-custom");

  catSelect.addEventListener("change", e => {
    selectedNode.data.category = e.target.value;
    customWrapper.style.display = e.target.value === "custom" ? "block" : "none";
  });

  if (customInput) {
    customInput.addEventListener("input", e => {
      selectedNode.data.customCategory = e.target.value;
    });
  }

  setupSidebarSearch();
}
  // === ITEM SELECTED ===
  else if (selectedNode.type === "item") {
    sidebar.innerHTML = `
      <div>
        <div class="pill">Item</div>
        <h2>${selectedNode.data.name || "Item"}</h2>

        <div class="field-group">
          <label for="item-name">Name</label>
          <input id="item-name" value="${selectedNode.data.name || ""}">
        </div>

        <div class="field-group">
          <label for="item-type">Type</label>
          <input id="item-type" value="${selectedNode.data.itemType || ""}">
        </div>

        <div class="field-group">
          <label for="item-special">Special attributes</label>
          <textarea id="item-special">${selectedNode.data.special || ""}</textarea>
        </div>
      </div>
      ${sidebarSearchHTML()}
    `;

    document.getElementById("item-name").addEventListener("input", e => {
      selectedNode.data.name = e.target.value;
    });
    document.getElementById("item-type").addEventListener("input", e => {
      selectedNode.data.itemType = e.target.value;
    });
    document.getElementById("item-special").addEventListener("input", e => {
      selectedNode.data.special = e.target.value;
    });

    setupSidebarSearch();
  }

  // === BOOK SELECTED ===
  else if (selectedNode.type === "book") {
    const currPageIndex =
      typeof selectedNode.data.currentPage === "number"
        ? Math.min(Math.max(selectedNode.data.currentPage, 0), BOOK_MAX_PAGES - 1)
        : 0;

    sidebar.innerHTML = `
      <div>
        <div class="pill">Book</div>
        <h2>${selectedNode.data.title || "Book"}</h2>

        <div class="field-group">
          <label for="book-title">Title</label>
          <input id="book-title" value="${selectedNode.data.title || ""}">
        </div>

        <div class="field-group">
          <label for="book-cover">Cover colour</label>
          <select id="book-cover">
            <option value="#1C1E4F"${selectedNode.data.coverColor === "#1C1E4F" ? " selected" : ""}>Indigo</option>
            <option value="#601919"${selectedNode.data.coverColor === "#601919" ? " selected" : ""}>Red</option>
            <option value="#36225A"${selectedNode.data.coverColor === "#36225A" ? " selected" : ""}>Purple</option>
            <option value="#203F31"${selectedNode.data.coverColor === "#203F31" ? " selected" : ""}>Green</option>
          </select>
        </div>

        <div class="field-group">
          <label for="book-page">Page (1â€“${BOOK_MAX_PAGES})</label>
          <input
            id="book-page"
            type="number"
            min="1"
            max="${BOOK_MAX_PAGES}"
            value="${currPageIndex + 1}"
          >
        </div>

        <div class="field-group">
          <label for="book-page-content">Page text</label>
          <textarea id="book-page-content">${
            Array.isArray(selectedNode.data.pages)
              ? (selectedNode.data.pages[currPageIndex] || "")
              : ""
          }</textarea>
        </div>

        <p style="font-size:11px;margin-top:4px;color:inherit;">
          Tip: click the book in Edit mode to open/close the spread.
        </p>
      </div>
      ${sidebarSearchHTML()}
    `;

    const titleInput = document.getElementById("book-title");
    const coverSelect = document.getElementById("book-cover");
    const pageInput = document.getElementById("book-page");
    const textArea = document.getElementById("book-page-content");

    if (!Array.isArray(selectedNode.data.pages)) {
      selectedNode.data.pages = Array.from({ length: BOOK_MAX_PAGES }, () => "");
    }

    titleInput.addEventListener("input", e => {
      selectedNode.data.title = e.target.value;
    });

    coverSelect.addEventListener("change", e => {
      selectedNode.data.coverColor = e.target.value;
    });

    pageInput.addEventListener("input", e => {
      let num = parseInt(e.target.value, 10);
      if (Number.isNaN(num)) num = 1;
      num = Math.min(Math.max(num, 1), BOOK_MAX_PAGES);
      e.target.value = String(num);
      const idx = num - 1;
      selectedNode.data.currentPage = idx;
      textArea.value = selectedNode.data.pages[idx] || "";
    });

    textArea.addEventListener("input", e => {
      let num = parseInt(pageInput.value, 10);
      if (Number.isNaN(num)) num = 1;
      num = Math.min(Math.max(num, 1), BOOK_MAX_PAGES);
      const idx = num - 1;
      selectedNode.data.currentPage = idx;
      selectedNode.data.pages[idx] = e.target.value;
    });

    setupSidebarSearch();
  }

  // === NOTE SELECTED ===
  else {
    sidebar.innerHTML = `
      <div>
        <div class="pill">Note</div>
        <h2>${selectedNode.data.title || "Note"}</h2>

        <div class="field-group">
          <label for="note-title">Title</label>
          <input id="note-title" value="${selectedNode.data.title || ""}">
        </div>
        <div class="field-group">
          <label for="note-content">Content</label>
          <textarea id="note-content">${selectedNode.data.content || ""}</textarea>
        </div>
      </div>
      ${sidebarSearchHTML()}
    `;

    document.getElementById("note-title").addEventListener("input", e => {
  let v = e.target.value;
  if (v.length > NOTE_MAX_TITLE_CHARS) {
    v = v.slice(0, NOTE_MAX_TITLE_CHARS);
    e.target.value = v;          // keep the UI in sync
  }
  selectedNode.data.title = v;
});

document.getElementById("note-content").addEventListener("input", e => {
  let v = e.target.value;
  if (v.length > NOTE_MAX_CONTENT_CHARS) {
    v = v.slice(0, NOTE_MAX_CONTENT_CHARS);
    e.target.value = v;
  }
  selectedNode.data.content = v;
});
nodes.forEach(n => {
  if (n.type === "note" && n.data) {
    if (typeof n.data.title === "string") {
      n.data.title = n.data.title.slice(0, NOTE_MAX_TITLE_CHARS);
    }
    if (typeof n.data.content === "string") {
      n.data.content = n.data.content.slice(0, NOTE_MAX_CONTENT_CHARS);
    }
  }
  if (typeof n.vx !== "number") n.vx = 0;
  if (typeof n.vy !== "number") n.vy = 0;
});


    setupSidebarSearch();
  }
}


    // Mode buttons
const modeButtons = document.querySelectorAll(".mode-button[data-mode]");

// Tooltip text for each tool
const modeTooltips = {
  move: "Drag nodes/bubbles and pan the canvas.",
  connect: "Click two nodes to create a relationship.",
  edit: "Select a node or bubble to edit its details.",
  delete: "Delete nodes, bubbles, or connections you click.",
  explode: "Trigger a shockwave that blasts everything away.",
  duplicate: "Click to clone a node or bubble.",
  autoconnect: "Connect this node to nearby nodes of the chosen relationship type.",
  isolate: "Remove all connections to the clicked node.",
};

modeButtons.forEach(btn => {
  const mode = btn.getAttribute("data-mode");
  if (modeTooltips[mode]) {
    btn.title = modeTooltips[mode];  // native hover tooltip
  }

  btn.addEventListener("click", () => {
    modeButtons.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    currentMode = mode;
    if (currentMode !== MODES.CONNECT) {
      connectSourceNode = null;
    }
    if (currentMode !== MODES.EDIT) {
      selectedNode = null;
      selectedBubble = null;
      renderSidebar();
    }
  });
});


    // Theme toggle (4 modes)
    const themeToggle = document.getElementById("themeToggle");

    function applyTheme() {
      const theme = getCurrentTheme();

      document.body.classList.remove("dark", "fantasy-light", "fantasy-dark");
      darkMode = false;

      if (theme === "dark") {
        document.body.classList.add("dark");
        darkMode = true;
      } else if (theme === "fantasyLight") {
        document.body.classList.add("fantasy-light");
        darkMode = false;
      } else if (theme === "fantasyDark") {
        document.body.classList.add("fantasy-dark");
        darkMode = true;
      }

      const iconSpan = themeToggle.querySelector(".icon");
      const labelSpan = themeToggle.querySelector("span:last-child");

      if (theme === "dark") {
        if (iconSpan) iconSpan.textContent = "â˜½";
        if (labelSpan) labelSpan.textContent = "Dark";
      } else if (theme === "fantasyLight") {
        if (iconSpan) iconSpan.textContent = "ð”ð”²ð”µ";
        if (labelSpan) labelSpan.textContent = "Fantasy Light";
      } else if (theme === "fantasyDark") {
        if (iconSpan) iconSpan.textContent = "ð”‘ð”¬ð”µ";
        if (labelSpan) labelSpan.textContent = "Fantasy Dark";
      } else if (theme === "light") {
        if (iconSpan) iconSpan.textContent = "â˜¼";
        if (labelSpan) labelSpan.textContent = "Light";
      }

      draw();
    }

    themeToggle.addEventListener("click", () => {
      currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
      localStorage.setItem("nb_themeIndex", String(currentThemeIndex));
      applyTheme();
    });

    applyTheme();

    // toolbar actions
    document.getElementById("newNodeButton").addEventListener("click", () => {
      const cx = (canvas.width / 2 - panX) / scale;
      const cy = (canvas.height / 2 - panY) / scale;
      const type = document.getElementById("nodeTypeSelect").value;
      const node = createNode(
        type,
        cx + (Math.random() * 200 - 100) / scale,
        cy + (Math.random() * 200 - 100) / scale
      );
      if (currentMode === MODES.EDIT) {
        selectedNode = node;
        selectedBubble = null;
        renderSidebar();
      }
    });

    document.getElementById("newBubbleButton").addEventListener("click", () => {
      const cx = (canvas.width / 2 - panX) / scale;
      const cy = (canvas.height / 2 - panY) / scale;
      const bubble = createBubble(cx, cy);
      if (currentMode === MODES.EDIT) {
        selectedBubble = bubble;
        selectedNode = null;
        renderSidebar();
      }
    });

    document.getElementById("saveButton").addEventListener("click", () => {
      normalizeEdges();
      localStorage.setItem("nb_nodes", JSON.stringify(nodes));
      localStorage.setItem("nb_edges", JSON.stringify(edges));
      localStorage.setItem("nb_bubbles", JSON.stringify(bubbles));
      alert("Saved graph to your browser storage.");
    });

    document.getElementById("loadButton").addEventListener("click", () => {
      const savedNodes = localStorage.getItem("nb_nodes");
      const savedEdges = localStorage.getItem("nb_edges");
      const savedBubbles = localStorage.getItem("nb_bubbles");
      if (!savedNodes || !savedEdges) {
        alert("No saved graph found.");
        return;
      }
      nodes = JSON.parse(savedNodes);
      edges = JSON.parse(savedEdges);
      bubbles = savedBubbles ? JSON.parse(savedBubbles) : [];

      edges.forEach(e => {
        if (!e.direction) e.direction = "forward";
      });
      normalizeEdges();

      nodes.forEach(n => {
        if (typeof n.vx !== "number") n.vx = 0;
        if (typeof n.vy !== "number") n.vy = 0;
      });
      bubbles.forEach(b => {
        if (typeof b.vx !== "number") b.vx = 0;
        if (typeof b.vy !== "number") b.vy = 0;
        if (typeof b.radius !== "number") b.radius = BUBBLE_BASE_RADIUS;
      });

      nextNodeId = nodes.reduce((max, n) => Math.max(max, n.id), 0) + 1;
      nextBubbleId = bubbles.reduce((max, b) => Math.max(max, b.id), 0) + 1;

      selectedNode = null;
      selectedBubble = null;
      connectSourceNode = null;
      renderSidebar();
    });

    document.getElementById("clearButton").addEventListener("click", () => {
      if (!confirm("Clear all nodes, bubbles, and connections?")) return;
      nodes = [];
      edges = [];
      bubbles = [];
      selectedNode = null;
      selectedBubble = null;
      connectSourceNode = null;
      renderSidebar();
    });

    // JSON save/load
    const saveJsonButton = document.getElementById("saveJsonButton");
    const loadJsonButton = document.getElementById("loadJsonButton");
    const jsonFileInput = document.getElementById("jsonFileInput");

    saveJsonButton.addEventListener("click", () => {
      normalizeEdges();
      const data = JSON.stringify({ nodes, edges, bubbles }, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "worldbuilder-graph.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    loadJsonButton.addEventListener("click", () => {
      jsonFileInput.value = "";
      jsonFileInput.click();
    });

    jsonFileInput.addEventListener("change", () => {
      const file = jsonFileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
            alert("JSON format not recognised. Expected { nodes: [...], edges: [...], bubbles?: [...] }.");
            return;
          }
          nodes = data.nodes;
          edges = data.edges;
          bubbles = Array.isArray(data.bubbles) ? data.bubbles : [];

          edges.forEach(e => {
            if (!e.direction) e.direction = "forward";
          });
          normalizeEdges();
          nodes.forEach(n => {
            if (typeof n.vx !== "number") n.vx = 0;
            if (typeof n.vy !== "number") n.vy = 0;
          });
          bubbles.forEach(b => {
            if (typeof b.vx !== "number") b.vx = 0;
            if (typeof b.vy !== "number") b.vy = 0;
            if (typeof b.radius !== "number") b.radius = BUBBLE_BASE_RADIUS;
          });

          nextNodeId = nodes.reduce((max, n) => Math.max(max, n.id), 0) + 1;
          nextBubbleId = bubbles.reduce((max, b) => Math.max(max, b.id), 0) + 1;

          selectedNode = null;
          selectedBubble = null;
          connectSourceNode = null;
          renderSidebar();
          alert("JSON loaded successfully.");
        } catch (err) {
          console.error(err);
          alert("Failed to parse JSON file.");
        }
      };
      reader.readAsText(file);
    });

    // canvas interaction
    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const world = screenToWorld(sx, sy);

      const node = getNodeAtWorld(world.x, world.y);

            if (currentMode === MODES.MOVE) {
          if (node) {
      draggingNode = node;
      draggingBubble = null;
      dragTarget = { x: world.x, y: world.y };
    } else {
      const bubble = getBubbleAtWorld(world.x, world.y);
      if (bubble) {
        draggingBubble = bubble;
        draggingNode = null;
        // NEW: use a target so physics lerps it instead of snapping
        bubbleDragTarget = { x: world.x, y: world.y };
      } else {
        draggingNode = null;
        draggingBubble = null;
        isPanning = true;
        lastPanScreen = { x: sx, y: sy };
      }
    }


            } else if (currentMode === MODES.CONNECT) {
        if (node) {
          // 1st click: pick a source node
          if (!connectSourceNode) {
            connectSourceNode = node;
          }
          // Click same node again: cancel
          else if (connectSourceNode.id === node.id) {
            connectSourceNode = null;
          }
          // 2nd node: create / update edge
          else {
            const type = document.getElementById("connectionTypeSelect").value;

            // Check if an edge of this type already exists between them
            let existing = edges.find(
              e =>
                e.type === type &&
                (
                  (e.fromId === connectSourceNode.id && e.toId === node.id) ||
                  (e.fromId === node.id && e.toId === connectSourceNode.id)
                )
            );

            if (!existing) {
              // Create a one-way edge from source â†’ target
              edges.push({
                fromId: connectSourceNode.id,
                toId: node.id,
                type,
                direction: "forward",
              });
            } else {
              // If it already exists, make it bidirectional
              existing.direction = "both";
            }

            normalizeEdges();
            connectSourceNode = null;
          }
        } else {
          // Clicked on empty space: clear pending source
          connectSourceNode = null;
        }

      } else if (currentMode === MODES.EDIT) {
  if (node) {
    // toggle collapsed/expanded when a note is clicked
    if (node.type === "note") {
      node.isExpanded = !node.isExpanded;
    } else if (node.type === "book") {
      node.isOpen = !node.isOpen;
    }
    selectedNode = node;
    selectedBubble = null;
  } else {
    const bubble = getBubbleAtWorld(world.x, world.y);
    if (bubble) {
      selectedBubble = bubble;
      selectedNode = null;
    } else {
      selectedNode = null;
      selectedBubble = null;
    }
  }
  renderSidebar();


      // ðŸ” NEW: DUPLICATE MODE
      } else if (currentMode === MODES.DUPLICATE) {
        if (node) {
          const copy = duplicateNode(node);
          selectedNode = copy;
          selectedBubble = null;
          renderSidebar();
        } else {
          const bubble = getBubbleAtWorld(world.x, world.y);
          if (bubble) {
            const bubbleCopy = {
              id: nextBubbleId++,
              name: (bubble.name || "Bubble") + " (copy)",
              x: bubble.x + 60,
              y: bubble.y + 60,
              radius: bubble.radius,
              vx: 0,
              vy: 0,
              nodeCount: 0,
            };
            bubbles.push(bubbleCopy);
            selectedBubble = bubbleCopy;
            selectedNode = null;
            renderSidebar();
          }
        }

      // AUTO CONNECT MODE
      } else if (currentMode === MODES.AUTOCONNECT) {
        if (node) {
          const type = document.getElementById("connectionTypeSelect").value;
          const center = node;
          let createdCount = 0;

          nodes.forEach(other => {
            if (other.id === center.id) return;

            const dx = other.x - center.x;
            const dy = other.y - center.y;
            const dist = Math.hypot(dx, dy);

            if (dist > AUTO_CONNECT_RADIUS) return;

            // Does this type already exist between A and B?
            let existing = edges.find(
              e =>
                e.type === type &&
                (
                  (e.fromId === center.id && e.toId === other.id) ||
                  (e.fromId === other.id && e.toId === center.id)
                )
            );

            if (!existing) {
              // Create one-way edge A â†’ B
              edges.push({
                fromId: center.id,
                toId: other.id,
                type,
                direction: "forward",
              });
              createdCount++;
            } else {
              // If the type already exists, upgrade to both-direction
              if (existing.direction !== "both") {
                existing.direction = "both";
              }
            }
          });

          normalizeEdges();

          // keep the clicked node selected
          selectedNode = center;
          selectedBubble = null;
          renderSidebar();

          // Debug / optional feedback
          console.log(`Auto Connect: created/updated links to ${createdCount} nodes.`);
        }

      } else if (currentMode === MODES.EXPLODE) {
        triggerExplosion(world.x, world.y, e.clientX, e.clientY);

      } else if (currentMode === MODES.ISOLATE) {
        if (node) {
          edges = edges.filter(
            e => e.fromId !== node.id && e.toId !== node.id
          );
          normalizeEdges();
          selectedNode = node;
          selectedBubble = null;
          renderSidebar();
        }

      } else if (currentMode === MODES.DELETE) {
        const edgeIndex = getEdgeAtWorld(world.x, world.y);
        if (edgeIndex !== -1) {
          edges.splice(edgeIndex, 1);
          return;
        }
        if (node) {
          const id = node.id;
          nodes = nodes.filter(n => n.id !== id);
          edges = edges.filter(e => e.fromId !== id && e.toId !== id);
          if (selectedNode && selectedNode.id === id) {
            selectedNode = null;
          }
          renderSidebar();
          return;
        }
        const bubble = getBubbleAtWorld(world.x, world.y);
        if (bubble) {
          const id = bubble.id;
          bubbles = bubbles.filter(b => b.id !== id);
          if (selectedBubble && selectedBubble.id === id) {
            selectedBubble = null;
          }
          renderSidebar();
        }
      }

    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

        if (currentMode === MODES.MOVE) {
    if (draggingNode) {
      const world = screenToWorld(sx, sy);
      dragTarget = { x: world.x, y: world.y };
    } else if (draggingBubble) {
      const world = screenToWorld(sx, sy);
      // move the *target*, physics will pull the bubble toward it
      bubbleDragTarget = { x: world.x, y: world.y };
    } else if (isPanning) {
      const dx = sx - lastPanScreen.x;
      const dy = sy - lastPanScreen.y;
      panX += dx;
      panY += dy;
      lastPanScreen = { x: sx, y: sy };
    }
  }
    });

    canvas.addEventListener("mouseup", () => {
      draggingNode = null;
      draggingBubble = null;
      isPanning = false;
    });

    canvas.addEventListener("mouseleave", () => {
      draggingNode = null;
      draggingBubble = null;
      isPanning = false;
    });

    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      const worldBeforeZoom = screenToWorld(sx, sy);

      const delta = -e.deltaY;
      const zoomFactor = delta > 0 ? 1.1 : 0.9;
      const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * zoomFactor));
      scale = newScale;

      panX = sx - worldBeforeZoom.x * scale;
      panY = sy - worldBeforeZoom.y * scale;
    }, { passive: false });

    // autosave graph + view + theme when leaving the page
    window.addEventListener("beforeunload", () => {
      try {
        normalizeEdges();
        localStorage.setItem("nb_nodes_auto", JSON.stringify(nodes));
        localStorage.setItem("nb_edges_auto", JSON.stringify(edges));
        localStorage.setItem("nb_bubbles_auto", JSON.stringify(bubbles));
        localStorage.setItem(
          "nb_view",
          JSON.stringify({ panX, panY, scale })
        );
        localStorage.setItem("nb_themeIndex", String(currentThemeIndex));
      } catch (e) {
        // ignore storage errors
      }
    });

    renderSidebar();
    physics();
  </script>
  <div id="copyright">
  Copyright Â© 2025<br> 
  Murdo John Macleod.<br> 
  All rights reserved.
</div>
</body>
</html>
